// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ExternalCommunication.proto

#ifndef PROTOBUF_ExternalCommunication_2eproto__INCLUDED
#define PROTOBUF_ExternalCommunication_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ExternalCommunication_2eproto();
void protobuf_AssignDesc_ExternalCommunication_2eproto();
void protobuf_ShutdownFile_ExternalCommunication_2eproto();

class ConfigUpdate;
class HandShake;
class FileTransfer;
class ExternalConfig;
class ExternalCommand;
class GenericACK;

enum ExternalCommand_SIMPLE_ACTIONS {
  ExternalCommand_SIMPLE_ACTIONS_SHUTDOWN = 0,
  ExternalCommand_SIMPLE_ACTIONS_STIFFNESS_OFF = 1,
  ExternalCommand_SIMPLE_ACTIONS_STOP_ROBOT = 2,
  ExternalCommand_SIMPLE_ACTIONS_SIT = 3,
  ExternalCommand_SIMPLE_ACTIONS_SIMPLE_ACTIONS_SIZE = 4
};
bool ExternalCommand_SIMPLE_ACTIONS_IsValid(int value);
const ExternalCommand_SIMPLE_ACTIONS ExternalCommand_SIMPLE_ACTIONS_SIMPLE_ACTIONS_MIN = ExternalCommand_SIMPLE_ACTIONS_SHUTDOWN;
const ExternalCommand_SIMPLE_ACTIONS ExternalCommand_SIMPLE_ACTIONS_SIMPLE_ACTIONS_MAX = ExternalCommand_SIMPLE_ACTIONS_SIMPLE_ACTIONS_SIZE;
const int ExternalCommand_SIMPLE_ACTIONS_SIMPLE_ACTIONS_ARRAYSIZE = ExternalCommand_SIMPLE_ACTIONS_SIMPLE_ACTIONS_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExternalCommand_SIMPLE_ACTIONS_descriptor();
inline const ::std::string& ExternalCommand_SIMPLE_ACTIONS_Name(ExternalCommand_SIMPLE_ACTIONS value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExternalCommand_SIMPLE_ACTIONS_descriptor(), value);
}
inline bool ExternalCommand_SIMPLE_ACTIONS_Parse(
    const ::std::string& name, ExternalCommand_SIMPLE_ACTIONS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExternalCommand_SIMPLE_ACTIONS>(
    ExternalCommand_SIMPLE_ACTIONS_descriptor(), name, value);
}
enum ExternalCommand_GAMECONTROLLER {
  ExternalCommand_GAMECONTROLLER_INITIAL = 0,
  ExternalCommand_GAMECONTROLLER_READY = 1,
  ExternalCommand_GAMECONTROLLER_SET = 2,
  ExternalCommand_GAMECONTROLLER_PLAY = 3,
  ExternalCommand_GAMECONTROLLER_PENALISED = 4,
  ExternalCommand_GAMECONTROLLER_FINISH = 5,
  ExternalCommand_GAMECONTROLLER_OVERRIDE = 6,
  ExternalCommand_GAMECONTROLLER_GAMECONTROLLER_SIZE = 7
};
bool ExternalCommand_GAMECONTROLLER_IsValid(int value);
const ExternalCommand_GAMECONTROLLER ExternalCommand_GAMECONTROLLER_GAMECONTROLLER_MIN = ExternalCommand_GAMECONTROLLER_INITIAL;
const ExternalCommand_GAMECONTROLLER ExternalCommand_GAMECONTROLLER_GAMECONTROLLER_MAX = ExternalCommand_GAMECONTROLLER_GAMECONTROLLER_SIZE;
const int ExternalCommand_GAMECONTROLLER_GAMECONTROLLER_ARRAYSIZE = ExternalCommand_GAMECONTROLLER_GAMECONTROLLER_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExternalCommand_GAMECONTROLLER_descriptor();
inline const ::std::string& ExternalCommand_GAMECONTROLLER_Name(ExternalCommand_GAMECONTROLLER value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExternalCommand_GAMECONTROLLER_descriptor(), value);
}
inline bool ExternalCommand_GAMECONTROLLER_Parse(
    const ::std::string& name, ExternalCommand_GAMECONTROLLER* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExternalCommand_GAMECONTROLLER>(
    ExternalCommand_GAMECONTROLLER_descriptor(), name, value);
}
enum ExternalCommand_LOCALIZATION {
  ExternalCommand_LOCALIZATION_INIT_PARTICLES = 0,
  ExternalCommand_LOCALIZATION_LOCALIZATION_SIZE = 1
};
bool ExternalCommand_LOCALIZATION_IsValid(int value);
const ExternalCommand_LOCALIZATION ExternalCommand_LOCALIZATION_LOCALIZATION_MIN = ExternalCommand_LOCALIZATION_INIT_PARTICLES;
const ExternalCommand_LOCALIZATION ExternalCommand_LOCALIZATION_LOCALIZATION_MAX = ExternalCommand_LOCALIZATION_LOCALIZATION_SIZE;
const int ExternalCommand_LOCALIZATION_LOCALIZATION_ARRAYSIZE = ExternalCommand_LOCALIZATION_LOCALIZATION_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExternalCommand_LOCALIZATION_descriptor();
inline const ::std::string& ExternalCommand_LOCALIZATION_Name(ExternalCommand_LOCALIZATION value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExternalCommand_LOCALIZATION_descriptor(), value);
}
inline bool ExternalCommand_LOCALIZATION_Parse(
    const ::std::string& name, ExternalCommand_LOCALIZATION* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExternalCommand_LOCALIZATION>(
    ExternalCommand_LOCALIZATION_descriptor(), name, value);
}
enum ExternalCommand_MOTION {
  ExternalCommand_MOTION_EXECUTE_ACTION = 0,
  ExternalCommand_MOTION_SET_STIFFNESS = 1,
  ExternalCommand_MOTION_MOTION_SIZE = 2
};
bool ExternalCommand_MOTION_IsValid(int value);
const ExternalCommand_MOTION ExternalCommand_MOTION_MOTION_MIN = ExternalCommand_MOTION_EXECUTE_ACTION;
const ExternalCommand_MOTION ExternalCommand_MOTION_MOTION_MAX = ExternalCommand_MOTION_MOTION_SIZE;
const int ExternalCommand_MOTION_MOTION_ARRAYSIZE = ExternalCommand_MOTION_MOTION_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExternalCommand_MOTION_descriptor();
inline const ::std::string& ExternalCommand_MOTION_Name(ExternalCommand_MOTION value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExternalCommand_MOTION_descriptor(), value);
}
inline bool ExternalCommand_MOTION_Parse(
    const ::std::string& name, ExternalCommand_MOTION* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExternalCommand_MOTION>(
    ExternalCommand_MOTION_descriptor(), name, value);
}
enum ExternalCommand_HEAD {
  ExternalCommand_HEAD_NOTHING = 0,
  ExternalCommand_HEAD_LOOK_DOWN = 1,
  ExternalCommand_HEAD_SCAN_AND_TRACK = 2,
  ExternalCommand_HEAD_LOCALIZE = 3,
  ExternalCommand_HEAD_LOCALIZE_FAR = 4,
  ExternalCommand_HEAD_SMART_SCAN = 5,
  ExternalCommand_HEAD_HEAD_SIZE = 6
};
bool ExternalCommand_HEAD_IsValid(int value);
const ExternalCommand_HEAD ExternalCommand_HEAD_HEAD_MIN = ExternalCommand_HEAD_NOTHING;
const ExternalCommand_HEAD ExternalCommand_HEAD_HEAD_MAX = ExternalCommand_HEAD_HEAD_SIZE;
const int ExternalCommand_HEAD_HEAD_ARRAYSIZE = ExternalCommand_HEAD_HEAD_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExternalCommand_HEAD_descriptor();
inline const ::std::string& ExternalCommand_HEAD_Name(ExternalCommand_HEAD value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExternalCommand_HEAD_descriptor(), value);
}
inline bool ExternalCommand_HEAD_Parse(
    const ::std::string& name, ExternalCommand_HEAD* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExternalCommand_HEAD>(
    ExternalCommand_HEAD_descriptor(), name, value);
}
// ===================================================================

class ConfigUpdate : public ::google::protobuf::Message {
 public:
  ConfigUpdate();
  virtual ~ConfigUpdate();
  
  ConfigUpdate(const ConfigUpdate& from);
  
  inline ConfigUpdate& operator=(const ConfigUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigUpdate& default_instance();
  
  void Swap(ConfigUpdate* other);
  
  // implements Message ----------------------------------------------
  
  ConfigUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConfigUpdate& from);
  void MergeFrom(const ConfigUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string keyword = 1;
  inline bool has_keyword() const;
  inline void clear_keyword();
  static const int kKeywordFieldNumber = 1;
  inline const ::std::string& keyword() const;
  inline void set_keyword(const ::std::string& value);
  inline void set_keyword(const char* value);
  inline void set_keyword(const char* value, size_t size);
  inline ::std::string* mutable_keyword();
  inline ::std::string* release_keyword();
  
  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:ConfigUpdate)
 private:
  inline void set_has_keyword();
  inline void clear_has_keyword();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* keyword_;
  ::std::string* value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ExternalCommunication_2eproto();
  friend void protobuf_AssignDesc_ExternalCommunication_2eproto();
  friend void protobuf_ShutdownFile_ExternalCommunication_2eproto();
  
  void InitAsDefaultInstance();
  static ConfigUpdate* default_instance_;
};
// -------------------------------------------------------------------

class HandShake : public ::google::protobuf::Message {
 public:
  HandShake();
  virtual ~HandShake();
  
  HandShake(const HandShake& from);
  
  inline HandShake& operator=(const HandShake& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HandShake& default_instance();
  
  void Swap(HandShake* other);
  
  // implements Message ----------------------------------------------
  
  HandShake* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HandShake& from);
  void MergeFrom(const HandShake& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string headId = 1;
  inline bool has_headid() const;
  inline void clear_headid();
  static const int kHeadIdFieldNumber = 1;
  inline const ::std::string& headid() const;
  inline void set_headid(const ::std::string& value);
  inline void set_headid(const char* value);
  inline void set_headid(const char* value, size_t size);
  inline ::std::string* mutable_headid();
  inline ::std::string* release_headid();
  
  // required string bodyId = 2;
  inline bool has_bodyid() const;
  inline void clear_bodyid();
  static const int kBodyIdFieldNumber = 2;
  inline const ::std::string& bodyid() const;
  inline void set_bodyid(const ::std::string& value);
  inline void set_bodyid(const char* value);
  inline void set_bodyid(const char* value, size_t size);
  inline ::std::string* mutable_bodyid();
  inline ::std::string* release_bodyid();
  
  // required uint32 checksum = 3;
  inline bool has_checksum() const;
  inline void clear_checksum();
  static const int kChecksumFieldNumber = 3;
  inline ::google::protobuf::uint32 checksum() const;
  inline void set_checksum(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:HandShake)
 private:
  inline void set_has_headid();
  inline void clear_has_headid();
  inline void set_has_bodyid();
  inline void clear_has_bodyid();
  inline void set_has_checksum();
  inline void clear_has_checksum();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* headid_;
  ::std::string* bodyid_;
  ::google::protobuf::uint32 checksum_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ExternalCommunication_2eproto();
  friend void protobuf_AssignDesc_ExternalCommunication_2eproto();
  friend void protobuf_ShutdownFile_ExternalCommunication_2eproto();
  
  void InitAsDefaultInstance();
  static HandShake* default_instance_;
};
// -------------------------------------------------------------------

class FileTransfer : public ::google::protobuf::Message {
 public:
  FileTransfer();
  virtual ~FileTransfer();
  
  FileTransfer(const FileTransfer& from);
  
  inline FileTransfer& operator=(const FileTransfer& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FileTransfer& default_instance();
  
  void Swap(FileTransfer* other);
  
  // implements Message ----------------------------------------------
  
  FileTransfer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileTransfer& from);
  void MergeFrom(const FileTransfer& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes file = 1;
  inline bool has_file() const;
  inline void clear_file();
  static const int kFileFieldNumber = 1;
  inline const ::std::string& file() const;
  inline void set_file(const ::std::string& value);
  inline void set_file(const char* value);
  inline void set_file(const void* value, size_t size);
  inline ::std::string* mutable_file();
  inline ::std::string* release_file();
  
  // required string filepath = 2;
  inline bool has_filepath() const;
  inline void clear_filepath();
  static const int kFilepathFieldNumber = 2;
  inline const ::std::string& filepath() const;
  inline void set_filepath(const ::std::string& value);
  inline void set_filepath(const char* value);
  inline void set_filepath(const char* value, size_t size);
  inline ::std::string* mutable_filepath();
  inline ::std::string* release_filepath();
  
  // @@protoc_insertion_point(class_scope:FileTransfer)
 private:
  inline void set_has_file();
  inline void clear_has_file();
  inline void set_has_filepath();
  inline void clear_has_filepath();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* file_;
  ::std::string* filepath_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ExternalCommunication_2eproto();
  friend void protobuf_AssignDesc_ExternalCommunication_2eproto();
  friend void protobuf_ShutdownFile_ExternalCommunication_2eproto();
  
  void InitAsDefaultInstance();
  static FileTransfer* default_instance_;
};
// -------------------------------------------------------------------

class ExternalConfig : public ::google::protobuf::Message {
 public:
  ExternalConfig();
  virtual ~ExternalConfig();
  
  ExternalConfig(const ExternalConfig& from);
  
  inline ExternalConfig& operator=(const ExternalConfig& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExternalConfig& default_instance();
  
  void Swap(ExternalConfig* other);
  
  // implements Message ----------------------------------------------
  
  ExternalConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExternalConfig& from);
  void MergeFrom(const ExternalConfig& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string messageid = 1;
  inline bool has_messageid() const;
  inline void clear_messageid();
  static const int kMessageidFieldNumber = 1;
  inline const ::std::string& messageid() const;
  inline void set_messageid(const ::std::string& value);
  inline void set_messageid(const char* value);
  inline void set_messageid(const char* value, size_t size);
  inline ::std::string* mutable_messageid();
  inline ::std::string* release_messageid();
  
  // required uint32 targethost = 2;
  inline bool has_targethost() const;
  inline void clear_targethost();
  static const int kTargethostFieldNumber = 2;
  inline ::google::protobuf::uint32 targethost() const;
  inline void set_targethost(::google::protobuf::uint32 value);
  
  // repeated .ConfigUpdate updateConfig = 3;
  inline int updateconfig_size() const;
  inline void clear_updateconfig();
  static const int kUpdateConfigFieldNumber = 3;
  inline const ::ConfigUpdate& updateconfig(int index) const;
  inline ::ConfigUpdate* mutable_updateconfig(int index);
  inline ::ConfigUpdate* add_updateconfig();
  inline const ::google::protobuf::RepeatedPtrField< ::ConfigUpdate >&
      updateconfig() const;
  inline ::google::protobuf::RepeatedPtrField< ::ConfigUpdate >*
      mutable_updateconfig();
  
  // repeated string resetActivities = 4;
  inline int resetactivities_size() const;
  inline void clear_resetactivities();
  static const int kResetActivitiesFieldNumber = 4;
  inline const ::std::string& resetactivities(int index) const;
  inline ::std::string* mutable_resetactivities(int index);
  inline void set_resetactivities(int index, const ::std::string& value);
  inline void set_resetactivities(int index, const char* value);
  inline void set_resetactivities(int index, const char* value, size_t size);
  inline ::std::string* add_resetactivities();
  inline void add_resetactivities(const ::std::string& value);
  inline void add_resetactivities(const char* value);
  inline void add_resetactivities(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& resetactivities() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_resetactivities();
  
  // optional .FileTransfer file = 5;
  inline bool has_file() const;
  inline void clear_file();
  static const int kFileFieldNumber = 5;
  inline const ::FileTransfer& file() const;
  inline ::FileTransfer* mutable_file();
  inline ::FileTransfer* release_file();
  
  // required bool handOffRequest = 6;
  inline bool has_handoffrequest() const;
  inline void clear_handoffrequest();
  static const int kHandOffRequestFieldNumber = 6;
  inline bool handoffrequest() const;
  inline void set_handoffrequest(bool value);
  
  // @@protoc_insertion_point(class_scope:ExternalConfig)
 private:
  inline void set_has_messageid();
  inline void clear_has_messageid();
  inline void set_has_targethost();
  inline void clear_has_targethost();
  inline void set_has_file();
  inline void clear_has_file();
  inline void set_has_handoffrequest();
  inline void clear_has_handoffrequest();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* messageid_;
  ::google::protobuf::RepeatedPtrField< ::ConfigUpdate > updateconfig_;
  ::google::protobuf::RepeatedPtrField< ::std::string> resetactivities_;
  ::google::protobuf::uint32 targethost_;
  bool handoffrequest_;
  ::FileTransfer* file_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_ExternalCommunication_2eproto();
  friend void protobuf_AssignDesc_ExternalCommunication_2eproto();
  friend void protobuf_ShutdownFile_ExternalCommunication_2eproto();
  
  void InitAsDefaultInstance();
  static ExternalConfig* default_instance_;
};
// -------------------------------------------------------------------

class ExternalCommand : public ::google::protobuf::Message {
 public:
  ExternalCommand();
  virtual ~ExternalCommand();
  
  ExternalCommand(const ExternalCommand& from);
  
  inline ExternalCommand& operator=(const ExternalCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExternalCommand& default_instance();
  
  void Swap(ExternalCommand* other);
  
  // implements Message ----------------------------------------------
  
  ExternalCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExternalCommand& from);
  void MergeFrom(const ExternalCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ExternalCommand_SIMPLE_ACTIONS SIMPLE_ACTIONS;
  static const SIMPLE_ACTIONS SHUTDOWN = ExternalCommand_SIMPLE_ACTIONS_SHUTDOWN;
  static const SIMPLE_ACTIONS STIFFNESS_OFF = ExternalCommand_SIMPLE_ACTIONS_STIFFNESS_OFF;
  static const SIMPLE_ACTIONS STOP_ROBOT = ExternalCommand_SIMPLE_ACTIONS_STOP_ROBOT;
  static const SIMPLE_ACTIONS SIT = ExternalCommand_SIMPLE_ACTIONS_SIT;
  static const SIMPLE_ACTIONS SIMPLE_ACTIONS_SIZE = ExternalCommand_SIMPLE_ACTIONS_SIMPLE_ACTIONS_SIZE;
  static inline bool SIMPLE_ACTIONS_IsValid(int value) {
    return ExternalCommand_SIMPLE_ACTIONS_IsValid(value);
  }
  static const SIMPLE_ACTIONS SIMPLE_ACTIONS_MIN =
    ExternalCommand_SIMPLE_ACTIONS_SIMPLE_ACTIONS_MIN;
  static const SIMPLE_ACTIONS SIMPLE_ACTIONS_MAX =
    ExternalCommand_SIMPLE_ACTIONS_SIMPLE_ACTIONS_MAX;
  static const int SIMPLE_ACTIONS_ARRAYSIZE =
    ExternalCommand_SIMPLE_ACTIONS_SIMPLE_ACTIONS_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SIMPLE_ACTIONS_descriptor() {
    return ExternalCommand_SIMPLE_ACTIONS_descriptor();
  }
  static inline const ::std::string& SIMPLE_ACTIONS_Name(SIMPLE_ACTIONS value) {
    return ExternalCommand_SIMPLE_ACTIONS_Name(value);
  }
  static inline bool SIMPLE_ACTIONS_Parse(const ::std::string& name,
      SIMPLE_ACTIONS* value) {
    return ExternalCommand_SIMPLE_ACTIONS_Parse(name, value);
  }
  
  typedef ExternalCommand_GAMECONTROLLER GAMECONTROLLER;
  static const GAMECONTROLLER INITIAL = ExternalCommand_GAMECONTROLLER_INITIAL;
  static const GAMECONTROLLER READY = ExternalCommand_GAMECONTROLLER_READY;
  static const GAMECONTROLLER SET = ExternalCommand_GAMECONTROLLER_SET;
  static const GAMECONTROLLER PLAY = ExternalCommand_GAMECONTROLLER_PLAY;
  static const GAMECONTROLLER PENALISED = ExternalCommand_GAMECONTROLLER_PENALISED;
  static const GAMECONTROLLER FINISH = ExternalCommand_GAMECONTROLLER_FINISH;
  static const GAMECONTROLLER OVERRIDE = ExternalCommand_GAMECONTROLLER_OVERRIDE;
  static const GAMECONTROLLER GAMECONTROLLER_SIZE = ExternalCommand_GAMECONTROLLER_GAMECONTROLLER_SIZE;
  static inline bool GAMECONTROLLER_IsValid(int value) {
    return ExternalCommand_GAMECONTROLLER_IsValid(value);
  }
  static const GAMECONTROLLER GAMECONTROLLER_MIN =
    ExternalCommand_GAMECONTROLLER_GAMECONTROLLER_MIN;
  static const GAMECONTROLLER GAMECONTROLLER_MAX =
    ExternalCommand_GAMECONTROLLER_GAMECONTROLLER_MAX;
  static const int GAMECONTROLLER_ARRAYSIZE =
    ExternalCommand_GAMECONTROLLER_GAMECONTROLLER_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GAMECONTROLLER_descriptor() {
    return ExternalCommand_GAMECONTROLLER_descriptor();
  }
  static inline const ::std::string& GAMECONTROLLER_Name(GAMECONTROLLER value) {
    return ExternalCommand_GAMECONTROLLER_Name(value);
  }
  static inline bool GAMECONTROLLER_Parse(const ::std::string& name,
      GAMECONTROLLER* value) {
    return ExternalCommand_GAMECONTROLLER_Parse(name, value);
  }
  
  typedef ExternalCommand_LOCALIZATION LOCALIZATION;
  static const LOCALIZATION INIT_PARTICLES = ExternalCommand_LOCALIZATION_INIT_PARTICLES;
  static const LOCALIZATION LOCALIZATION_SIZE = ExternalCommand_LOCALIZATION_LOCALIZATION_SIZE;
  static inline bool LOCALIZATION_IsValid(int value) {
    return ExternalCommand_LOCALIZATION_IsValid(value);
  }
  static const LOCALIZATION LOCALIZATION_MIN =
    ExternalCommand_LOCALIZATION_LOCALIZATION_MIN;
  static const LOCALIZATION LOCALIZATION_MAX =
    ExternalCommand_LOCALIZATION_LOCALIZATION_MAX;
  static const int LOCALIZATION_ARRAYSIZE =
    ExternalCommand_LOCALIZATION_LOCALIZATION_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LOCALIZATION_descriptor() {
    return ExternalCommand_LOCALIZATION_descriptor();
  }
  static inline const ::std::string& LOCALIZATION_Name(LOCALIZATION value) {
    return ExternalCommand_LOCALIZATION_Name(value);
  }
  static inline bool LOCALIZATION_Parse(const ::std::string& name,
      LOCALIZATION* value) {
    return ExternalCommand_LOCALIZATION_Parse(name, value);
  }
  
  typedef ExternalCommand_MOTION MOTION;
  static const MOTION EXECUTE_ACTION = ExternalCommand_MOTION_EXECUTE_ACTION;
  static const MOTION SET_STIFFNESS = ExternalCommand_MOTION_SET_STIFFNESS;
  static const MOTION MOTION_SIZE = ExternalCommand_MOTION_MOTION_SIZE;
  static inline bool MOTION_IsValid(int value) {
    return ExternalCommand_MOTION_IsValid(value);
  }
  static const MOTION MOTION_MIN =
    ExternalCommand_MOTION_MOTION_MIN;
  static const MOTION MOTION_MAX =
    ExternalCommand_MOTION_MOTION_MAX;
  static const int MOTION_ARRAYSIZE =
    ExternalCommand_MOTION_MOTION_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MOTION_descriptor() {
    return ExternalCommand_MOTION_descriptor();
  }
  static inline const ::std::string& MOTION_Name(MOTION value) {
    return ExternalCommand_MOTION_Name(value);
  }
  static inline bool MOTION_Parse(const ::std::string& name,
      MOTION* value) {
    return ExternalCommand_MOTION_Parse(name, value);
  }
  
  typedef ExternalCommand_HEAD HEAD;
  static const HEAD NOTHING = ExternalCommand_HEAD_NOTHING;
  static const HEAD LOOK_DOWN = ExternalCommand_HEAD_LOOK_DOWN;
  static const HEAD SCAN_AND_TRACK = ExternalCommand_HEAD_SCAN_AND_TRACK;
  static const HEAD LOCALIZE = ExternalCommand_HEAD_LOCALIZE;
  static const HEAD LOCALIZE_FAR = ExternalCommand_HEAD_LOCALIZE_FAR;
  static const HEAD SMART_SCAN = ExternalCommand_HEAD_SMART_SCAN;
  static const HEAD HEAD_SIZE = ExternalCommand_HEAD_HEAD_SIZE;
  static inline bool HEAD_IsValid(int value) {
    return ExternalCommand_HEAD_IsValid(value);
  }
  static const HEAD HEAD_MIN =
    ExternalCommand_HEAD_HEAD_MIN;
  static const HEAD HEAD_MAX =
    ExternalCommand_HEAD_HEAD_MAX;
  static const int HEAD_ARRAYSIZE =
    ExternalCommand_HEAD_HEAD_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HEAD_descriptor() {
    return ExternalCommand_HEAD_descriptor();
  }
  static inline const ::std::string& HEAD_Name(HEAD value) {
    return ExternalCommand_HEAD_Name(value);
  }
  static inline bool HEAD_Parse(const ::std::string& name,
      HEAD* value) {
    return ExternalCommand_HEAD_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required string messageid = 1;
  inline bool has_messageid() const;
  inline void clear_messageid();
  static const int kMessageidFieldNumber = 1;
  inline const ::std::string& messageid() const;
  inline void set_messageid(const ::std::string& value);
  inline void set_messageid(const char* value);
  inline void set_messageid(const char* value, size_t size);
  inline ::std::string* mutable_messageid();
  inline ::std::string* release_messageid();
  
  // required uint32 targethost = 2;
  inline bool has_targethost() const;
  inline void clear_targethost();
  static const int kTargethostFieldNumber = 2;
  inline ::google::protobuf::uint32 targethost() const;
  inline void set_targethost(::google::protobuf::uint32 value);
  
  // required uint32 commandID = 3;
  inline bool has_commandid() const;
  inline void clear_commandid();
  static const int kCommandIDFieldNumber = 3;
  inline ::google::protobuf::uint32 commandid() const;
  inline void set_commandid(::google::protobuf::uint32 value);
  
  // repeated float floatvars = 4;
  inline int floatvars_size() const;
  inline void clear_floatvars();
  static const int kFloatvarsFieldNumber = 4;
  inline float floatvars(int index) const;
  inline void set_floatvars(int index, float value);
  inline void add_floatvars(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      floatvars() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_floatvars();
  
  // optional string stringvars = 5;
  inline bool has_stringvars() const;
  inline void clear_stringvars();
  static const int kStringvarsFieldNumber = 5;
  inline const ::std::string& stringvars() const;
  inline void set_stringvars(const ::std::string& value);
  inline void set_stringvars(const char* value);
  inline void set_stringvars(const char* value, size_t size);
  inline ::std::string* mutable_stringvars();
  inline ::std::string* release_stringvars();
  
  // @@protoc_insertion_point(class_scope:ExternalCommand)
 private:
  inline void set_has_messageid();
  inline void clear_has_messageid();
  inline void set_has_targethost();
  inline void clear_has_targethost();
  inline void set_has_commandid();
  inline void clear_has_commandid();
  inline void set_has_stringvars();
  inline void clear_has_stringvars();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* messageid_;
  ::google::protobuf::uint32 targethost_;
  ::google::protobuf::uint32 commandid_;
  ::google::protobuf::RepeatedField< float > floatvars_;
  ::std::string* stringvars_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_ExternalCommunication_2eproto();
  friend void protobuf_AssignDesc_ExternalCommunication_2eproto();
  friend void protobuf_ShutdownFile_ExternalCommunication_2eproto();
  
  void InitAsDefaultInstance();
  static ExternalCommand* default_instance_;
};
// -------------------------------------------------------------------

class GenericACK : public ::google::protobuf::Message {
 public:
  GenericACK();
  virtual ~GenericACK();
  
  GenericACK(const GenericACK& from);
  
  inline GenericACK& operator=(const GenericACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GenericACK& default_instance();
  
  void Swap(GenericACK* other);
  
  // implements Message ----------------------------------------------
  
  GenericACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GenericACK& from);
  void MergeFrom(const GenericACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 hostid = 1;
  inline bool has_hostid() const;
  inline void clear_hostid();
  static const int kHostidFieldNumber = 1;
  inline ::google::protobuf::uint32 hostid() const;
  inline void set_hostid(::google::protobuf::uint32 value);
  
  // required string messageid = 2;
  inline bool has_messageid() const;
  inline void clear_messageid();
  static const int kMessageidFieldNumber = 2;
  inline const ::std::string& messageid() const;
  inline void set_messageid(const ::std::string& value);
  inline void set_messageid(const char* value);
  inline void set_messageid(const char* value, size_t size);
  inline ::std::string* mutable_messageid();
  inline ::std::string* release_messageid();
  
  // optional .HandShake handshaking = 3;
  inline bool has_handshaking() const;
  inline void clear_handshaking();
  static const int kHandshakingFieldNumber = 3;
  inline const ::HandShake& handshaking() const;
  inline ::HandShake* mutable_handshaking();
  inline ::HandShake* release_handshaking();
  
  // required bool ownlock = 4;
  inline bool has_ownlock() const;
  inline void clear_ownlock();
  static const int kOwnlockFieldNumber = 4;
  inline bool ownlock() const;
  inline void set_ownlock(bool value);
  
  // @@protoc_insertion_point(class_scope:GenericACK)
 private:
  inline void set_has_hostid();
  inline void clear_has_hostid();
  inline void set_has_messageid();
  inline void clear_has_messageid();
  inline void set_has_handshaking();
  inline void clear_has_handshaking();
  inline void set_has_ownlock();
  inline void clear_has_ownlock();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* messageid_;
  ::google::protobuf::uint32 hostid_;
  bool ownlock_;
  ::HandShake* handshaking_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_ExternalCommunication_2eproto();
  friend void protobuf_AssignDesc_ExternalCommunication_2eproto();
  friend void protobuf_ShutdownFile_ExternalCommunication_2eproto();
  
  void InitAsDefaultInstance();
  static GenericACK* default_instance_;
};
// ===================================================================


// ===================================================================

// ConfigUpdate

// required string keyword = 1;
inline bool ConfigUpdate::has_keyword() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigUpdate::set_has_keyword() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigUpdate::clear_has_keyword() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigUpdate::clear_keyword() {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    keyword_->clear();
  }
  clear_has_keyword();
}
inline const ::std::string& ConfigUpdate::keyword() const {
  return *keyword_;
}
inline void ConfigUpdate::set_keyword(const ::std::string& value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void ConfigUpdate::set_keyword(const char* value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void ConfigUpdate::set_keyword(const char* value, size_t size) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConfigUpdate::mutable_keyword() {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  return keyword_;
}
inline ::std::string* ConfigUpdate::release_keyword() {
  clear_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keyword_;
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string value = 2;
inline bool ConfigUpdate::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConfigUpdate::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConfigUpdate::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConfigUpdate::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& ConfigUpdate::value() const {
  return *value_;
}
inline void ConfigUpdate::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ConfigUpdate::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ConfigUpdate::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConfigUpdate::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* ConfigUpdate::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// HandShake

// required string headId = 1;
inline bool HandShake::has_headid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HandShake::set_has_headid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HandShake::clear_has_headid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HandShake::clear_headid() {
  if (headid_ != &::google::protobuf::internal::kEmptyString) {
    headid_->clear();
  }
  clear_has_headid();
}
inline const ::std::string& HandShake::headid() const {
  return *headid_;
}
inline void HandShake::set_headid(const ::std::string& value) {
  set_has_headid();
  if (headid_ == &::google::protobuf::internal::kEmptyString) {
    headid_ = new ::std::string;
  }
  headid_->assign(value);
}
inline void HandShake::set_headid(const char* value) {
  set_has_headid();
  if (headid_ == &::google::protobuf::internal::kEmptyString) {
    headid_ = new ::std::string;
  }
  headid_->assign(value);
}
inline void HandShake::set_headid(const char* value, size_t size) {
  set_has_headid();
  if (headid_ == &::google::protobuf::internal::kEmptyString) {
    headid_ = new ::std::string;
  }
  headid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HandShake::mutable_headid() {
  set_has_headid();
  if (headid_ == &::google::protobuf::internal::kEmptyString) {
    headid_ = new ::std::string;
  }
  return headid_;
}
inline ::std::string* HandShake::release_headid() {
  clear_has_headid();
  if (headid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headid_;
    headid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string bodyId = 2;
inline bool HandShake::has_bodyid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HandShake::set_has_bodyid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HandShake::clear_has_bodyid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HandShake::clear_bodyid() {
  if (bodyid_ != &::google::protobuf::internal::kEmptyString) {
    bodyid_->clear();
  }
  clear_has_bodyid();
}
inline const ::std::string& HandShake::bodyid() const {
  return *bodyid_;
}
inline void HandShake::set_bodyid(const ::std::string& value) {
  set_has_bodyid();
  if (bodyid_ == &::google::protobuf::internal::kEmptyString) {
    bodyid_ = new ::std::string;
  }
  bodyid_->assign(value);
}
inline void HandShake::set_bodyid(const char* value) {
  set_has_bodyid();
  if (bodyid_ == &::google::protobuf::internal::kEmptyString) {
    bodyid_ = new ::std::string;
  }
  bodyid_->assign(value);
}
inline void HandShake::set_bodyid(const char* value, size_t size) {
  set_has_bodyid();
  if (bodyid_ == &::google::protobuf::internal::kEmptyString) {
    bodyid_ = new ::std::string;
  }
  bodyid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HandShake::mutable_bodyid() {
  set_has_bodyid();
  if (bodyid_ == &::google::protobuf::internal::kEmptyString) {
    bodyid_ = new ::std::string;
  }
  return bodyid_;
}
inline ::std::string* HandShake::release_bodyid() {
  clear_has_bodyid();
  if (bodyid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bodyid_;
    bodyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 checksum = 3;
inline bool HandShake::has_checksum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HandShake::set_has_checksum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HandShake::clear_has_checksum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HandShake::clear_checksum() {
  checksum_ = 0u;
  clear_has_checksum();
}
inline ::google::protobuf::uint32 HandShake::checksum() const {
  return checksum_;
}
inline void HandShake::set_checksum(::google::protobuf::uint32 value) {
  set_has_checksum();
  checksum_ = value;
}

// -------------------------------------------------------------------

// FileTransfer

// required bytes file = 1;
inline bool FileTransfer::has_file() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileTransfer::set_has_file() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileTransfer::clear_has_file() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileTransfer::clear_file() {
  if (file_ != &::google::protobuf::internal::kEmptyString) {
    file_->clear();
  }
  clear_has_file();
}
inline const ::std::string& FileTransfer::file() const {
  return *file_;
}
inline void FileTransfer::set_file(const ::std::string& value) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  file_->assign(value);
}
inline void FileTransfer::set_file(const char* value) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  file_->assign(value);
}
inline void FileTransfer::set_file(const void* value, size_t size) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileTransfer::mutable_file() {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  return file_;
}
inline ::std::string* FileTransfer::release_file() {
  clear_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_;
    file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string filepath = 2;
inline bool FileTransfer::has_filepath() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileTransfer::set_has_filepath() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileTransfer::clear_has_filepath() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileTransfer::clear_filepath() {
  if (filepath_ != &::google::protobuf::internal::kEmptyString) {
    filepath_->clear();
  }
  clear_has_filepath();
}
inline const ::std::string& FileTransfer::filepath() const {
  return *filepath_;
}
inline void FileTransfer::set_filepath(const ::std::string& value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
}
inline void FileTransfer::set_filepath(const char* value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
}
inline void FileTransfer::set_filepath(const char* value, size_t size) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileTransfer::mutable_filepath() {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  return filepath_;
}
inline ::std::string* FileTransfer::release_filepath() {
  clear_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filepath_;
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ExternalConfig

// required string messageid = 1;
inline bool ExternalConfig::has_messageid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExternalConfig::set_has_messageid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExternalConfig::clear_has_messageid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExternalConfig::clear_messageid() {
  if (messageid_ != &::google::protobuf::internal::kEmptyString) {
    messageid_->clear();
  }
  clear_has_messageid();
}
inline const ::std::string& ExternalConfig::messageid() const {
  return *messageid_;
}
inline void ExternalConfig::set_messageid(const ::std::string& value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
}
inline void ExternalConfig::set_messageid(const char* value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
}
inline void ExternalConfig::set_messageid(const char* value, size_t size) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExternalConfig::mutable_messageid() {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  return messageid_;
}
inline ::std::string* ExternalConfig::release_messageid() {
  clear_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = messageid_;
    messageid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 targethost = 2;
inline bool ExternalConfig::has_targethost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExternalConfig::set_has_targethost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExternalConfig::clear_has_targethost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExternalConfig::clear_targethost() {
  targethost_ = 0u;
  clear_has_targethost();
}
inline ::google::protobuf::uint32 ExternalConfig::targethost() const {
  return targethost_;
}
inline void ExternalConfig::set_targethost(::google::protobuf::uint32 value) {
  set_has_targethost();
  targethost_ = value;
}

// repeated .ConfigUpdate updateConfig = 3;
inline int ExternalConfig::updateconfig_size() const {
  return updateconfig_.size();
}
inline void ExternalConfig::clear_updateconfig() {
  updateconfig_.Clear();
}
inline const ::ConfigUpdate& ExternalConfig::updateconfig(int index) const {
  return updateconfig_.Get(index);
}
inline ::ConfigUpdate* ExternalConfig::mutable_updateconfig(int index) {
  return updateconfig_.Mutable(index);
}
inline ::ConfigUpdate* ExternalConfig::add_updateconfig() {
  return updateconfig_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ConfigUpdate >&
ExternalConfig::updateconfig() const {
  return updateconfig_;
}
inline ::google::protobuf::RepeatedPtrField< ::ConfigUpdate >*
ExternalConfig::mutable_updateconfig() {
  return &updateconfig_;
}

// repeated string resetActivities = 4;
inline int ExternalConfig::resetactivities_size() const {
  return resetactivities_.size();
}
inline void ExternalConfig::clear_resetactivities() {
  resetactivities_.Clear();
}
inline const ::std::string& ExternalConfig::resetactivities(int index) const {
  return resetactivities_.Get(index);
}
inline ::std::string* ExternalConfig::mutable_resetactivities(int index) {
  return resetactivities_.Mutable(index);
}
inline void ExternalConfig::set_resetactivities(int index, const ::std::string& value) {
  resetactivities_.Mutable(index)->assign(value);
}
inline void ExternalConfig::set_resetactivities(int index, const char* value) {
  resetactivities_.Mutable(index)->assign(value);
}
inline void ExternalConfig::set_resetactivities(int index, const char* value, size_t size) {
  resetactivities_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExternalConfig::add_resetactivities() {
  return resetactivities_.Add();
}
inline void ExternalConfig::add_resetactivities(const ::std::string& value) {
  resetactivities_.Add()->assign(value);
}
inline void ExternalConfig::add_resetactivities(const char* value) {
  resetactivities_.Add()->assign(value);
}
inline void ExternalConfig::add_resetactivities(const char* value, size_t size) {
  resetactivities_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ExternalConfig::resetactivities() const {
  return resetactivities_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ExternalConfig::mutable_resetactivities() {
  return &resetactivities_;
}

// optional .FileTransfer file = 5;
inline bool ExternalConfig::has_file() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExternalConfig::set_has_file() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExternalConfig::clear_has_file() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExternalConfig::clear_file() {
  if (file_ != NULL) file_->::FileTransfer::Clear();
  clear_has_file();
}
inline const ::FileTransfer& ExternalConfig::file() const {
  return file_ != NULL ? *file_ : *default_instance_->file_;
}
inline ::FileTransfer* ExternalConfig::mutable_file() {
  set_has_file();
  if (file_ == NULL) file_ = new ::FileTransfer;
  return file_;
}
inline ::FileTransfer* ExternalConfig::release_file() {
  clear_has_file();
  ::FileTransfer* temp = file_;
  file_ = NULL;
  return temp;
}

// required bool handOffRequest = 6;
inline bool ExternalConfig::has_handoffrequest() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExternalConfig::set_has_handoffrequest() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ExternalConfig::clear_has_handoffrequest() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ExternalConfig::clear_handoffrequest() {
  handoffrequest_ = false;
  clear_has_handoffrequest();
}
inline bool ExternalConfig::handoffrequest() const {
  return handoffrequest_;
}
inline void ExternalConfig::set_handoffrequest(bool value) {
  set_has_handoffrequest();
  handoffrequest_ = value;
}

// -------------------------------------------------------------------

// ExternalCommand

// required string messageid = 1;
inline bool ExternalCommand::has_messageid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExternalCommand::set_has_messageid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExternalCommand::clear_has_messageid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExternalCommand::clear_messageid() {
  if (messageid_ != &::google::protobuf::internal::kEmptyString) {
    messageid_->clear();
  }
  clear_has_messageid();
}
inline const ::std::string& ExternalCommand::messageid() const {
  return *messageid_;
}
inline void ExternalCommand::set_messageid(const ::std::string& value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
}
inline void ExternalCommand::set_messageid(const char* value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
}
inline void ExternalCommand::set_messageid(const char* value, size_t size) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExternalCommand::mutable_messageid() {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  return messageid_;
}
inline ::std::string* ExternalCommand::release_messageid() {
  clear_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = messageid_;
    messageid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 targethost = 2;
inline bool ExternalCommand::has_targethost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExternalCommand::set_has_targethost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExternalCommand::clear_has_targethost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExternalCommand::clear_targethost() {
  targethost_ = 0u;
  clear_has_targethost();
}
inline ::google::protobuf::uint32 ExternalCommand::targethost() const {
  return targethost_;
}
inline void ExternalCommand::set_targethost(::google::protobuf::uint32 value) {
  set_has_targethost();
  targethost_ = value;
}

// required uint32 commandID = 3;
inline bool ExternalCommand::has_commandid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExternalCommand::set_has_commandid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExternalCommand::clear_has_commandid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExternalCommand::clear_commandid() {
  commandid_ = 0u;
  clear_has_commandid();
}
inline ::google::protobuf::uint32 ExternalCommand::commandid() const {
  return commandid_;
}
inline void ExternalCommand::set_commandid(::google::protobuf::uint32 value) {
  set_has_commandid();
  commandid_ = value;
}

// repeated float floatvars = 4;
inline int ExternalCommand::floatvars_size() const {
  return floatvars_.size();
}
inline void ExternalCommand::clear_floatvars() {
  floatvars_.Clear();
}
inline float ExternalCommand::floatvars(int index) const {
  return floatvars_.Get(index);
}
inline void ExternalCommand::set_floatvars(int index, float value) {
  floatvars_.Set(index, value);
}
inline void ExternalCommand::add_floatvars(float value) {
  floatvars_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ExternalCommand::floatvars() const {
  return floatvars_;
}
inline ::google::protobuf::RepeatedField< float >*
ExternalCommand::mutable_floatvars() {
  return &floatvars_;
}

// optional string stringvars = 5;
inline bool ExternalCommand::has_stringvars() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExternalCommand::set_has_stringvars() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExternalCommand::clear_has_stringvars() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExternalCommand::clear_stringvars() {
  if (stringvars_ != &::google::protobuf::internal::kEmptyString) {
    stringvars_->clear();
  }
  clear_has_stringvars();
}
inline const ::std::string& ExternalCommand::stringvars() const {
  return *stringvars_;
}
inline void ExternalCommand::set_stringvars(const ::std::string& value) {
  set_has_stringvars();
  if (stringvars_ == &::google::protobuf::internal::kEmptyString) {
    stringvars_ = new ::std::string;
  }
  stringvars_->assign(value);
}
inline void ExternalCommand::set_stringvars(const char* value) {
  set_has_stringvars();
  if (stringvars_ == &::google::protobuf::internal::kEmptyString) {
    stringvars_ = new ::std::string;
  }
  stringvars_->assign(value);
}
inline void ExternalCommand::set_stringvars(const char* value, size_t size) {
  set_has_stringvars();
  if (stringvars_ == &::google::protobuf::internal::kEmptyString) {
    stringvars_ = new ::std::string;
  }
  stringvars_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExternalCommand::mutable_stringvars() {
  set_has_stringvars();
  if (stringvars_ == &::google::protobuf::internal::kEmptyString) {
    stringvars_ = new ::std::string;
  }
  return stringvars_;
}
inline ::std::string* ExternalCommand::release_stringvars() {
  clear_has_stringvars();
  if (stringvars_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stringvars_;
    stringvars_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GenericACK

// required uint32 hostid = 1;
inline bool GenericACK::has_hostid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GenericACK::set_has_hostid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GenericACK::clear_has_hostid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GenericACK::clear_hostid() {
  hostid_ = 0u;
  clear_has_hostid();
}
inline ::google::protobuf::uint32 GenericACK::hostid() const {
  return hostid_;
}
inline void GenericACK::set_hostid(::google::protobuf::uint32 value) {
  set_has_hostid();
  hostid_ = value;
}

// required string messageid = 2;
inline bool GenericACK::has_messageid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GenericACK::set_has_messageid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GenericACK::clear_has_messageid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GenericACK::clear_messageid() {
  if (messageid_ != &::google::protobuf::internal::kEmptyString) {
    messageid_->clear();
  }
  clear_has_messageid();
}
inline const ::std::string& GenericACK::messageid() const {
  return *messageid_;
}
inline void GenericACK::set_messageid(const ::std::string& value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
}
inline void GenericACK::set_messageid(const char* value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
}
inline void GenericACK::set_messageid(const char* value, size_t size) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GenericACK::mutable_messageid() {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  return messageid_;
}
inline ::std::string* GenericACK::release_messageid() {
  clear_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = messageid_;
    messageid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .HandShake handshaking = 3;
inline bool GenericACK::has_handshaking() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GenericACK::set_has_handshaking() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GenericACK::clear_has_handshaking() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GenericACK::clear_handshaking() {
  if (handshaking_ != NULL) handshaking_->::HandShake::Clear();
  clear_has_handshaking();
}
inline const ::HandShake& GenericACK::handshaking() const {
  return handshaking_ != NULL ? *handshaking_ : *default_instance_->handshaking_;
}
inline ::HandShake* GenericACK::mutable_handshaking() {
  set_has_handshaking();
  if (handshaking_ == NULL) handshaking_ = new ::HandShake;
  return handshaking_;
}
inline ::HandShake* GenericACK::release_handshaking() {
  clear_has_handshaking();
  ::HandShake* temp = handshaking_;
  handshaking_ = NULL;
  return temp;
}

// required bool ownlock = 4;
inline bool GenericACK::has_ownlock() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GenericACK::set_has_ownlock() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GenericACK::clear_has_ownlock() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GenericACK::clear_ownlock() {
  ownlock_ = false;
  clear_has_ownlock();
}
inline bool GenericACK::ownlock() const {
  return ownlock_;
}
inline void GenericACK::set_ownlock(bool value) {
  set_has_ownlock();
  ownlock_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ExternalCommand_SIMPLE_ACTIONS>() {
  return ::ExternalCommand_SIMPLE_ACTIONS_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ExternalCommand_GAMECONTROLLER>() {
  return ::ExternalCommand_GAMECONTROLLER_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ExternalCommand_LOCALIZATION>() {
  return ::ExternalCommand_LOCALIZATION_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ExternalCommand_MOTION>() {
  return ::ExternalCommand_MOTION_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ExternalCommand_HEAD>() {
  return ::ExternalCommand_HEAD_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ExternalCommunication_2eproto__INCLUDED
