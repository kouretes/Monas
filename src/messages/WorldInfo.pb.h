// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: WorldInfo.proto

#ifndef PROTOBUF_WorldInfo_2eproto__INCLUDED
#define PROTOBUF_WorldInfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "VisionObservations.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_WorldInfo_2eproto();
void protobuf_AssignDesc_WorldInfo_2eproto();
void protobuf_ShutdownFile_WorldInfo_2eproto();

class WorldInfo;
class SharedWorldInfo;
class TeammatePose;
class RobotPose;
class Ball;
class GlobalBall;
class LocalizationResetMessage;
class LocalizationData;
class header;

enum LocalizationResetMessage_RESET {
  LocalizationResetMessage_RESET_UNIFORM = 0,
  LocalizationResetMessage_RESET_READY = 1,
  LocalizationResetMessage_RESET_SET = 2,
  LocalizationResetMessage_RESET_PENALISED = 3,
  LocalizationResetMessage_RESET_MANUAL = 4,
  LocalizationResetMessage_RESET_PENALTY_MODE = 5
};
bool LocalizationResetMessage_RESET_IsValid(int value);
const LocalizationResetMessage_RESET LocalizationResetMessage_RESET_RESET_MIN = LocalizationResetMessage_RESET_UNIFORM;
const LocalizationResetMessage_RESET LocalizationResetMessage_RESET_RESET_MAX = LocalizationResetMessage_RESET_PENALTY_MODE;
const int LocalizationResetMessage_RESET_RESET_ARRAYSIZE = LocalizationResetMessage_RESET_RESET_MAX + 1;

const ::google::protobuf::EnumDescriptor* LocalizationResetMessage_RESET_descriptor();
inline const ::std::string& LocalizationResetMessage_RESET_Name(LocalizationResetMessage_RESET value) {
  return ::google::protobuf::internal::NameOfEnum(
    LocalizationResetMessage_RESET_descriptor(), value);
}
inline bool LocalizationResetMessage_RESET_Parse(
    const ::std::string& name, LocalizationResetMessage_RESET* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LocalizationResetMessage_RESET>(
    LocalizationResetMessage_RESET_descriptor(), name, value);
}
// ===================================================================

class WorldInfo : public ::google::protobuf::Message {
 public:
  WorldInfo();
  virtual ~WorldInfo();
  
  WorldInfo(const WorldInfo& from);
  
  inline WorldInfo& operator=(const WorldInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const WorldInfo& default_instance();
  
  void Swap(WorldInfo* other);
  
  // implements Message ----------------------------------------------
  
  WorldInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WorldInfo& from);
  void MergeFrom(const WorldInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .RobotPose myPosition = 1;
  inline bool has_myposition() const;
  inline void clear_myposition();
  static const int kMyPositionFieldNumber = 1;
  inline const ::RobotPose& myposition() const;
  inline ::RobotPose* mutable_myposition();
  inline ::RobotPose* release_myposition();
  
  // required uint32 playerNumber = 2;
  inline bool has_playernumber() const;
  inline void clear_playernumber();
  static const int kPlayerNumberFieldNumber = 2;
  inline ::google::protobuf::uint32 playernumber() const;
  inline void set_playernumber(::google::protobuf::uint32 value);
  
  // required uint32 stability = 3;
  inline bool has_stability() const;
  inline void clear_stability();
  static const int kStabilityFieldNumber = 3;
  inline ::google::protobuf::uint32 stability() const;
  inline void set_stability(::google::protobuf::uint32 value);
  
  // repeated .Ball Balls = 4;
  inline int balls_size() const;
  inline void clear_balls();
  static const int kBallsFieldNumber = 4;
  inline const ::Ball& balls(int index) const;
  inline ::Ball* mutable_balls(int index);
  inline ::Ball* add_balls();
  inline const ::google::protobuf::RepeatedPtrField< ::Ball >&
      balls() const;
  inline ::google::protobuf::RepeatedPtrField< ::Ball >*
      mutable_balls();
  
  // @@protoc_insertion_point(class_scope:WorldInfo)
 private:
  inline void set_has_myposition();
  inline void clear_has_myposition();
  inline void set_has_playernumber();
  inline void clear_has_playernumber();
  inline void set_has_stability();
  inline void clear_has_stability();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::RobotPose* myposition_;
  ::google::protobuf::uint32 playernumber_;
  ::google::protobuf::uint32 stability_;
  ::google::protobuf::RepeatedPtrField< ::Ball > balls_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_WorldInfo_2eproto();
  friend void protobuf_AssignDesc_WorldInfo_2eproto();
  friend void protobuf_ShutdownFile_WorldInfo_2eproto();
  
  void InitAsDefaultInstance();
  static WorldInfo* default_instance_;
};
// -------------------------------------------------------------------

class SharedWorldInfo : public ::google::protobuf::Message {
 public:
  SharedWorldInfo();
  virtual ~SharedWorldInfo();
  
  SharedWorldInfo(const SharedWorldInfo& from);
  
  inline SharedWorldInfo& operator=(const SharedWorldInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SharedWorldInfo& default_instance();
  
  void Swap(SharedWorldInfo* other);
  
  // implements Message ----------------------------------------------
  
  SharedWorldInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SharedWorldInfo& from);
  void MergeFrom(const SharedWorldInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 playerClosestToBall = 1;
  inline bool has_playerclosesttoball() const;
  inline void clear_playerclosesttoball();
  static const int kPlayerClosestToBallFieldNumber = 1;
  inline ::google::protobuf::uint32 playerclosesttoball() const;
  inline void set_playerclosesttoball(::google::protobuf::uint32 value);
  
  // repeated .TeammatePose teammatePosition = 2;
  inline int teammateposition_size() const;
  inline void clear_teammateposition();
  static const int kTeammatePositionFieldNumber = 2;
  inline const ::TeammatePose& teammateposition(int index) const;
  inline ::TeammatePose* mutable_teammateposition(int index);
  inline ::TeammatePose* add_teammateposition();
  inline const ::google::protobuf::RepeatedPtrField< ::TeammatePose >&
      teammateposition() const;
  inline ::google::protobuf::RepeatedPtrField< ::TeammatePose >*
      mutable_teammateposition();
  
  // repeated .GlobalBall GlobalBalls = 3;
  inline int globalballs_size() const;
  inline void clear_globalballs();
  static const int kGlobalBallsFieldNumber = 3;
  inline const ::GlobalBall& globalballs(int index) const;
  inline ::GlobalBall* mutable_globalballs(int index);
  inline ::GlobalBall* add_globalballs();
  inline const ::google::protobuf::RepeatedPtrField< ::GlobalBall >&
      globalballs() const;
  inline ::google::protobuf::RepeatedPtrField< ::GlobalBall >*
      mutable_globalballs();
  
  // @@protoc_insertion_point(class_scope:SharedWorldInfo)
 private:
  inline void set_has_playerclosesttoball();
  inline void clear_has_playerclosesttoball();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::TeammatePose > teammateposition_;
  ::google::protobuf::RepeatedPtrField< ::GlobalBall > globalballs_;
  ::google::protobuf::uint32 playerclosesttoball_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_WorldInfo_2eproto();
  friend void protobuf_AssignDesc_WorldInfo_2eproto();
  friend void protobuf_ShutdownFile_WorldInfo_2eproto();
  
  void InitAsDefaultInstance();
  static SharedWorldInfo* default_instance_;
};
// -------------------------------------------------------------------

class TeammatePose : public ::google::protobuf::Message {
 public:
  TeammatePose();
  virtual ~TeammatePose();
  
  TeammatePose(const TeammatePose& from);
  
  inline TeammatePose& operator=(const TeammatePose& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TeammatePose& default_instance();
  
  void Swap(TeammatePose* other);
  
  // implements Message ----------------------------------------------
  
  TeammatePose* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeammatePose& from);
  void MergeFrom(const TeammatePose& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .RobotPose pose = 1;
  inline bool has_pose() const;
  inline void clear_pose();
  static const int kPoseFieldNumber = 1;
  inline const ::RobotPose& pose() const;
  inline ::RobotPose* mutable_pose();
  inline ::RobotPose* release_pose();
  
  // required uint32 robotId = 2;
  inline bool has_robotid() const;
  inline void clear_robotid();
  static const int kRobotIdFieldNumber = 2;
  inline ::google::protobuf::uint32 robotid() const;
  inline void set_robotid(::google::protobuf::uint32 value);
  
  // required uint32 stability = 3;
  inline bool has_stability() const;
  inline void clear_stability();
  static const int kStabilityFieldNumber = 3;
  inline ::google::protobuf::uint32 stability() const;
  inline void set_stability(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:TeammatePose)
 private:
  inline void set_has_pose();
  inline void clear_has_pose();
  inline void set_has_robotid();
  inline void clear_has_robotid();
  inline void set_has_stability();
  inline void clear_has_stability();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::RobotPose* pose_;
  ::google::protobuf::uint32 robotid_;
  ::google::protobuf::uint32 stability_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_WorldInfo_2eproto();
  friend void protobuf_AssignDesc_WorldInfo_2eproto();
  friend void protobuf_ShutdownFile_WorldInfo_2eproto();
  
  void InitAsDefaultInstance();
  static TeammatePose* default_instance_;
};
// -------------------------------------------------------------------

class RobotPose : public ::google::protobuf::Message {
 public:
  RobotPose();
  virtual ~RobotPose();
  
  RobotPose(const RobotPose& from);
  
  inline RobotPose& operator=(const RobotPose& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotPose& default_instance();
  
  void Swap(RobotPose* other);
  
  // implements Message ----------------------------------------------
  
  RobotPose* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RobotPose& from);
  void MergeFrom(const RobotPose& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float X = 1 [default = -100000];
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // required float Y = 2 [default = -100000];
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // required float phi = 3 [default = -100000];
  inline bool has_phi() const;
  inline void clear_phi();
  static const int kPhiFieldNumber = 3;
  inline float phi() const;
  inline void set_phi(float value);
  
  // required float confidence = 4 [default = -100000];
  inline bool has_confidence() const;
  inline void clear_confidence();
  static const int kConfidenceFieldNumber = 4;
  inline float confidence() const;
  inline void set_confidence(float value);
  
  // repeated float var = 5;
  inline int var_size() const;
  inline void clear_var();
  static const int kVarFieldNumber = 5;
  inline float var(int index) const;
  inline void set_var(int index, float value);
  inline void add_var(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      var() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_var();
  
  // @@protoc_insertion_point(class_scope:RobotPose)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_phi();
  inline void clear_has_phi();
  inline void set_has_confidence();
  inline void clear_has_confidence();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float x_;
  float y_;
  float phi_;
  float confidence_;
  ::google::protobuf::RepeatedField< float > var_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_WorldInfo_2eproto();
  friend void protobuf_AssignDesc_WorldInfo_2eproto();
  friend void protobuf_ShutdownFile_WorldInfo_2eproto();
  
  void InitAsDefaultInstance();
  static RobotPose* default_instance_;
};
// -------------------------------------------------------------------

class Ball : public ::google::protobuf::Message {
 public:
  Ball();
  virtual ~Ball();
  
  Ball(const Ball& from);
  
  inline Ball& operator=(const Ball& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Ball& default_instance();
  
  void Swap(Ball* other);
  
  // implements Message ----------------------------------------------
  
  Ball* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ball& from);
  void MergeFrom(const Ball& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float relativeX = 1 [default = -100000];
  inline bool has_relativex() const;
  inline void clear_relativex();
  static const int kRelativeXFieldNumber = 1;
  inline float relativex() const;
  inline void set_relativex(float value);
  
  // required float relativeY = 2 [default = -100000];
  inline bool has_relativey() const;
  inline void clear_relativey();
  static const int kRelativeYFieldNumber = 2;
  inline float relativey() const;
  inline void set_relativey(float value);
  
  // required float relativeXspeed = 3 [default = 0];
  inline bool has_relativexspeed() const;
  inline void clear_relativexspeed();
  static const int kRelativeXspeedFieldNumber = 3;
  inline float relativexspeed() const;
  inline void set_relativexspeed(float value);
  
  // required float relativeYspeed = 4 [default = 0];
  inline bool has_relativeyspeed() const;
  inline void clear_relativeyspeed();
  static const int kRelativeYspeedFieldNumber = 4;
  inline float relativeyspeed() const;
  inline void set_relativeyspeed(float value);
  
  // required float absoluteX = 5 [default = -100000];
  inline bool has_absolutex() const;
  inline void clear_absolutex();
  static const int kAbsoluteXFieldNumber = 5;
  inline float absolutex() const;
  inline void set_absolutex(float value);
  
  // required float absoluteY = 6 [default = -100000];
  inline bool has_absolutey() const;
  inline void clear_absolutey();
  static const int kAbsoluteYFieldNumber = 6;
  inline float absolutey() const;
  inline void set_absolutey(float value);
  
  // required float absoluteXspeed = 7 [default = 0];
  inline bool has_absolutexspeed() const;
  inline void clear_absolutexspeed();
  static const int kAbsoluteXspeedFieldNumber = 7;
  inline float absolutexspeed() const;
  inline void set_absolutexspeed(float value);
  
  // required float absoluteYspeed = 8 [default = 0];
  inline bool has_absoluteyspeed() const;
  inline void clear_absoluteyspeed();
  static const int kAbsoluteYspeedFieldNumber = 8;
  inline float absoluteyspeed() const;
  inline void set_absoluteyspeed(float value);
  
  // @@protoc_insertion_point(class_scope:Ball)
 private:
  inline void set_has_relativex();
  inline void clear_has_relativex();
  inline void set_has_relativey();
  inline void clear_has_relativey();
  inline void set_has_relativexspeed();
  inline void clear_has_relativexspeed();
  inline void set_has_relativeyspeed();
  inline void clear_has_relativeyspeed();
  inline void set_has_absolutex();
  inline void clear_has_absolutex();
  inline void set_has_absolutey();
  inline void clear_has_absolutey();
  inline void set_has_absolutexspeed();
  inline void clear_has_absolutexspeed();
  inline void set_has_absoluteyspeed();
  inline void clear_has_absoluteyspeed();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float relativex_;
  float relativey_;
  float relativexspeed_;
  float relativeyspeed_;
  float absolutex_;
  float absolutey_;
  float absolutexspeed_;
  float absoluteyspeed_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_WorldInfo_2eproto();
  friend void protobuf_AssignDesc_WorldInfo_2eproto();
  friend void protobuf_ShutdownFile_WorldInfo_2eproto();
  
  void InitAsDefaultInstance();
  static Ball* default_instance_;
};
// -------------------------------------------------------------------

class GlobalBall : public ::google::protobuf::Message {
 public:
  GlobalBall();
  virtual ~GlobalBall();
  
  GlobalBall(const GlobalBall& from);
  
  inline GlobalBall& operator=(const GlobalBall& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GlobalBall& default_instance();
  
  void Swap(GlobalBall* other);
  
  // implements Message ----------------------------------------------
  
  GlobalBall* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GlobalBall& from);
  void MergeFrom(const GlobalBall& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float x = 1 [default = -100000];
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // required float y = 2 [default = -100000];
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // @@protoc_insertion_point(class_scope:GlobalBall)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float x_;
  float y_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_WorldInfo_2eproto();
  friend void protobuf_AssignDesc_WorldInfo_2eproto();
  friend void protobuf_ShutdownFile_WorldInfo_2eproto();
  
  void InitAsDefaultInstance();
  static GlobalBall* default_instance_;
};
// -------------------------------------------------------------------

class LocalizationResetMessage : public ::google::protobuf::Message {
 public:
  LocalizationResetMessage();
  virtual ~LocalizationResetMessage();
  
  LocalizationResetMessage(const LocalizationResetMessage& from);
  
  inline LocalizationResetMessage& operator=(const LocalizationResetMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalizationResetMessage& default_instance();
  
  void Swap(LocalizationResetMessage* other);
  
  // implements Message ----------------------------------------------
  
  LocalizationResetMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalizationResetMessage& from);
  void MergeFrom(const LocalizationResetMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef LocalizationResetMessage_RESET RESET;
  static const RESET UNIFORM = LocalizationResetMessage_RESET_UNIFORM;
  static const RESET READY = LocalizationResetMessage_RESET_READY;
  static const RESET SET = LocalizationResetMessage_RESET_SET;
  static const RESET PENALISED = LocalizationResetMessage_RESET_PENALISED;
  static const RESET MANUAL = LocalizationResetMessage_RESET_MANUAL;
  static const RESET PENALTY_MODE = LocalizationResetMessage_RESET_PENALTY_MODE;
  static inline bool RESET_IsValid(int value) {
    return LocalizationResetMessage_RESET_IsValid(value);
  }
  static const RESET RESET_MIN =
    LocalizationResetMessage_RESET_RESET_MIN;
  static const RESET RESET_MAX =
    LocalizationResetMessage_RESET_RESET_MAX;
  static const int RESET_ARRAYSIZE =
    LocalizationResetMessage_RESET_RESET_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RESET_descriptor() {
    return LocalizationResetMessage_RESET_descriptor();
  }
  static inline const ::std::string& RESET_Name(RESET value) {
    return LocalizationResetMessage_RESET_Name(value);
  }
  static inline bool RESET_Parse(const ::std::string& name,
      RESET* value) {
    return LocalizationResetMessage_RESET_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // required bool kickOff = 2;
  inline bool has_kickoff() const;
  inline void clear_kickoff();
  static const int kKickOffFieldNumber = 2;
  inline bool kickoff() const;
  inline void set_kickoff(bool value);
  
  // required float xPos = 3 [default = 0];
  inline bool has_xpos() const;
  inline void clear_xpos();
  static const int kXPosFieldNumber = 3;
  inline float xpos() const;
  inline void set_xpos(float value);
  
  // required float yPos = 4 [default = 0];
  inline bool has_ypos() const;
  inline void clear_ypos();
  static const int kYPosFieldNumber = 4;
  inline float ypos() const;
  inline void set_ypos(float value);
  
  // required float phiPos = 5 [default = 0];
  inline bool has_phipos() const;
  inline void clear_phipos();
  static const int kPhiPosFieldNumber = 5;
  inline float phipos() const;
  inline void set_phipos(float value);
  
  // @@protoc_insertion_point(class_scope:LocalizationResetMessage)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_kickoff();
  inline void clear_has_kickoff();
  inline void set_has_xpos();
  inline void clear_has_xpos();
  inline void set_has_ypos();
  inline void clear_has_ypos();
  inline void set_has_phipos();
  inline void clear_has_phipos();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 type_;
  bool kickoff_;
  float xpos_;
  float ypos_;
  float phipos_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_WorldInfo_2eproto();
  friend void protobuf_AssignDesc_WorldInfo_2eproto();
  friend void protobuf_ShutdownFile_WorldInfo_2eproto();
  
  void InitAsDefaultInstance();
  static LocalizationResetMessage* default_instance_;
};
// -------------------------------------------------------------------

class LocalizationData : public ::google::protobuf::Message {
 public:
  LocalizationData();
  virtual ~LocalizationData();
  
  LocalizationData(const LocalizationData& from);
  
  inline LocalizationData& operator=(const LocalizationData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalizationData& default_instance();
  
  void Swap(LocalizationData* other);
  
  // implements Message ----------------------------------------------
  
  LocalizationData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalizationData& from);
  void MergeFrom(const LocalizationData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .WorldInfo World = 1;
  inline bool has_world() const;
  inline void clear_world();
  static const int kWorldFieldNumber = 1;
  inline const ::WorldInfo& world() const;
  inline ::WorldInfo* mutable_world();
  inline ::WorldInfo* release_world();
  
  // repeated .RobotPose Particles = 2;
  inline int particles_size() const;
  inline void clear_particles();
  static const int kParticlesFieldNumber = 2;
  inline const ::RobotPose& particles(int index) const;
  inline ::RobotPose* mutable_particles(int index);
  inline ::RobotPose* add_particles();
  inline const ::google::protobuf::RepeatedPtrField< ::RobotPose >&
      particles() const;
  inline ::google::protobuf::RepeatedPtrField< ::RobotPose >*
      mutable_particles();
  
  // required .RobotPose RobotPosition = 3;
  inline bool has_robotposition() const;
  inline void clear_robotposition();
  static const int kRobotPositionFieldNumber = 3;
  inline const ::RobotPose& robotposition() const;
  inline ::RobotPose* mutable_robotposition();
  inline ::RobotPose* release_robotposition();
  
  // required .ObservationMessage Observations = 4;
  inline bool has_observations() const;
  inline void clear_observations();
  static const int kObservationsFieldNumber = 4;
  inline const ::ObservationMessage& observations() const;
  inline ::ObservationMessage* mutable_observations();
  inline ::ObservationMessage* release_observations();
  
  // @@protoc_insertion_point(class_scope:LocalizationData)
 private:
  inline void set_has_world();
  inline void clear_has_world();
  inline void set_has_robotposition();
  inline void clear_has_robotposition();
  inline void set_has_observations();
  inline void clear_has_observations();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::WorldInfo* world_;
  ::google::protobuf::RepeatedPtrField< ::RobotPose > particles_;
  ::RobotPose* robotposition_;
  ::ObservationMessage* observations_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_WorldInfo_2eproto();
  friend void protobuf_AssignDesc_WorldInfo_2eproto();
  friend void protobuf_ShutdownFile_WorldInfo_2eproto();
  
  void InitAsDefaultInstance();
  static LocalizationData* default_instance_;
};
// -------------------------------------------------------------------

class header : public ::google::protobuf::Message {
 public:
  header();
  virtual ~header();
  
  header(const header& from);
  
  inline header& operator=(const header& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const header& default_instance();
  
  void Swap(header* other);
  
  // implements Message ----------------------------------------------
  
  header* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const header& from);
  void MergeFrom(const header& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 NextMsgByteSize = 1 [default = -1];
  inline bool has_nextmsgbytesize() const;
  inline void clear_nextmsgbytesize();
  static const int kNextMsgByteSizeFieldNumber = 1;
  inline ::google::protobuf::int32 nextmsgbytesize() const;
  inline void set_nextmsgbytesize(::google::protobuf::int32 value);
  
  // required bytes NextMsgName = 3 [default = "Undef"];
  inline bool has_nextmsgname() const;
  inline void clear_nextmsgname();
  static const int kNextMsgNameFieldNumber = 3;
  inline const ::std::string& nextmsgname() const;
  inline void set_nextmsgname(const ::std::string& value);
  inline void set_nextmsgname(const char* value);
  inline void set_nextmsgname(const void* value, size_t size);
  inline ::std::string* mutable_nextmsgname();
  inline ::std::string* release_nextmsgname();
  
  // @@protoc_insertion_point(class_scope:header)
 private:
  inline void set_has_nextmsgbytesize();
  inline void clear_has_nextmsgbytesize();
  inline void set_has_nextmsgname();
  inline void clear_has_nextmsgname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* nextmsgname_;
  static const ::std::string _default_nextmsgname_;
  ::google::protobuf::int32 nextmsgbytesize_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_WorldInfo_2eproto();
  friend void protobuf_AssignDesc_WorldInfo_2eproto();
  friend void protobuf_ShutdownFile_WorldInfo_2eproto();
  
  void InitAsDefaultInstance();
  static header* default_instance_;
};
// ===================================================================


// ===================================================================

// WorldInfo

// required .RobotPose myPosition = 1;
inline bool WorldInfo::has_myposition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WorldInfo::set_has_myposition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WorldInfo::clear_has_myposition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WorldInfo::clear_myposition() {
  if (myposition_ != NULL) myposition_->::RobotPose::Clear();
  clear_has_myposition();
}
inline const ::RobotPose& WorldInfo::myposition() const {
  return myposition_ != NULL ? *myposition_ : *default_instance_->myposition_;
}
inline ::RobotPose* WorldInfo::mutable_myposition() {
  set_has_myposition();
  if (myposition_ == NULL) myposition_ = new ::RobotPose;
  return myposition_;
}
inline ::RobotPose* WorldInfo::release_myposition() {
  clear_has_myposition();
  ::RobotPose* temp = myposition_;
  myposition_ = NULL;
  return temp;
}

// required uint32 playerNumber = 2;
inline bool WorldInfo::has_playernumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WorldInfo::set_has_playernumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WorldInfo::clear_has_playernumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WorldInfo::clear_playernumber() {
  playernumber_ = 0u;
  clear_has_playernumber();
}
inline ::google::protobuf::uint32 WorldInfo::playernumber() const {
  return playernumber_;
}
inline void WorldInfo::set_playernumber(::google::protobuf::uint32 value) {
  set_has_playernumber();
  playernumber_ = value;
}

// required uint32 stability = 3;
inline bool WorldInfo::has_stability() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WorldInfo::set_has_stability() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WorldInfo::clear_has_stability() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WorldInfo::clear_stability() {
  stability_ = 0u;
  clear_has_stability();
}
inline ::google::protobuf::uint32 WorldInfo::stability() const {
  return stability_;
}
inline void WorldInfo::set_stability(::google::protobuf::uint32 value) {
  set_has_stability();
  stability_ = value;
}

// repeated .Ball Balls = 4;
inline int WorldInfo::balls_size() const {
  return balls_.size();
}
inline void WorldInfo::clear_balls() {
  balls_.Clear();
}
inline const ::Ball& WorldInfo::balls(int index) const {
  return balls_.Get(index);
}
inline ::Ball* WorldInfo::mutable_balls(int index) {
  return balls_.Mutable(index);
}
inline ::Ball* WorldInfo::add_balls() {
  return balls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Ball >&
WorldInfo::balls() const {
  return balls_;
}
inline ::google::protobuf::RepeatedPtrField< ::Ball >*
WorldInfo::mutable_balls() {
  return &balls_;
}

// -------------------------------------------------------------------

// SharedWorldInfo

// required uint32 playerClosestToBall = 1;
inline bool SharedWorldInfo::has_playerclosesttoball() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SharedWorldInfo::set_has_playerclosesttoball() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SharedWorldInfo::clear_has_playerclosesttoball() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SharedWorldInfo::clear_playerclosesttoball() {
  playerclosesttoball_ = 0u;
  clear_has_playerclosesttoball();
}
inline ::google::protobuf::uint32 SharedWorldInfo::playerclosesttoball() const {
  return playerclosesttoball_;
}
inline void SharedWorldInfo::set_playerclosesttoball(::google::protobuf::uint32 value) {
  set_has_playerclosesttoball();
  playerclosesttoball_ = value;
}

// repeated .TeammatePose teammatePosition = 2;
inline int SharedWorldInfo::teammateposition_size() const {
  return teammateposition_.size();
}
inline void SharedWorldInfo::clear_teammateposition() {
  teammateposition_.Clear();
}
inline const ::TeammatePose& SharedWorldInfo::teammateposition(int index) const {
  return teammateposition_.Get(index);
}
inline ::TeammatePose* SharedWorldInfo::mutable_teammateposition(int index) {
  return teammateposition_.Mutable(index);
}
inline ::TeammatePose* SharedWorldInfo::add_teammateposition() {
  return teammateposition_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TeammatePose >&
SharedWorldInfo::teammateposition() const {
  return teammateposition_;
}
inline ::google::protobuf::RepeatedPtrField< ::TeammatePose >*
SharedWorldInfo::mutable_teammateposition() {
  return &teammateposition_;
}

// repeated .GlobalBall GlobalBalls = 3;
inline int SharedWorldInfo::globalballs_size() const {
  return globalballs_.size();
}
inline void SharedWorldInfo::clear_globalballs() {
  globalballs_.Clear();
}
inline const ::GlobalBall& SharedWorldInfo::globalballs(int index) const {
  return globalballs_.Get(index);
}
inline ::GlobalBall* SharedWorldInfo::mutable_globalballs(int index) {
  return globalballs_.Mutable(index);
}
inline ::GlobalBall* SharedWorldInfo::add_globalballs() {
  return globalballs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GlobalBall >&
SharedWorldInfo::globalballs() const {
  return globalballs_;
}
inline ::google::protobuf::RepeatedPtrField< ::GlobalBall >*
SharedWorldInfo::mutable_globalballs() {
  return &globalballs_;
}

// -------------------------------------------------------------------

// TeammatePose

// required .RobotPose pose = 1;
inline bool TeammatePose::has_pose() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeammatePose::set_has_pose() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeammatePose::clear_has_pose() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeammatePose::clear_pose() {
  if (pose_ != NULL) pose_->::RobotPose::Clear();
  clear_has_pose();
}
inline const ::RobotPose& TeammatePose::pose() const {
  return pose_ != NULL ? *pose_ : *default_instance_->pose_;
}
inline ::RobotPose* TeammatePose::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) pose_ = new ::RobotPose;
  return pose_;
}
inline ::RobotPose* TeammatePose::release_pose() {
  clear_has_pose();
  ::RobotPose* temp = pose_;
  pose_ = NULL;
  return temp;
}

// required uint32 robotId = 2;
inline bool TeammatePose::has_robotid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TeammatePose::set_has_robotid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TeammatePose::clear_has_robotid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TeammatePose::clear_robotid() {
  robotid_ = 0u;
  clear_has_robotid();
}
inline ::google::protobuf::uint32 TeammatePose::robotid() const {
  return robotid_;
}
inline void TeammatePose::set_robotid(::google::protobuf::uint32 value) {
  set_has_robotid();
  robotid_ = value;
}

// required uint32 stability = 3;
inline bool TeammatePose::has_stability() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TeammatePose::set_has_stability() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TeammatePose::clear_has_stability() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TeammatePose::clear_stability() {
  stability_ = 0u;
  clear_has_stability();
}
inline ::google::protobuf::uint32 TeammatePose::stability() const {
  return stability_;
}
inline void TeammatePose::set_stability(::google::protobuf::uint32 value) {
  set_has_stability();
  stability_ = value;
}

// -------------------------------------------------------------------

// RobotPose

// required float X = 1 [default = -100000];
inline bool RobotPose::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotPose::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotPose::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotPose::clear_x() {
  x_ = -100000;
  clear_has_x();
}
inline float RobotPose::x() const {
  return x_;
}
inline void RobotPose::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float Y = 2 [default = -100000];
inline bool RobotPose::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotPose::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotPose::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotPose::clear_y() {
  y_ = -100000;
  clear_has_y();
}
inline float RobotPose::y() const {
  return y_;
}
inline void RobotPose::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required float phi = 3 [default = -100000];
inline bool RobotPose::has_phi() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RobotPose::set_has_phi() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RobotPose::clear_has_phi() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RobotPose::clear_phi() {
  phi_ = -100000;
  clear_has_phi();
}
inline float RobotPose::phi() const {
  return phi_;
}
inline void RobotPose::set_phi(float value) {
  set_has_phi();
  phi_ = value;
}

// required float confidence = 4 [default = -100000];
inline bool RobotPose::has_confidence() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RobotPose::set_has_confidence() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RobotPose::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RobotPose::clear_confidence() {
  confidence_ = -100000;
  clear_has_confidence();
}
inline float RobotPose::confidence() const {
  return confidence_;
}
inline void RobotPose::set_confidence(float value) {
  set_has_confidence();
  confidence_ = value;
}

// repeated float var = 5;
inline int RobotPose::var_size() const {
  return var_.size();
}
inline void RobotPose::clear_var() {
  var_.Clear();
}
inline float RobotPose::var(int index) const {
  return var_.Get(index);
}
inline void RobotPose::set_var(int index, float value) {
  var_.Set(index, value);
}
inline void RobotPose::add_var(float value) {
  var_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
RobotPose::var() const {
  return var_;
}
inline ::google::protobuf::RepeatedField< float >*
RobotPose::mutable_var() {
  return &var_;
}

// -------------------------------------------------------------------

// Ball

// required float relativeX = 1 [default = -100000];
inline bool Ball::has_relativex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ball::set_has_relativex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ball::clear_has_relativex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ball::clear_relativex() {
  relativex_ = -100000;
  clear_has_relativex();
}
inline float Ball::relativex() const {
  return relativex_;
}
inline void Ball::set_relativex(float value) {
  set_has_relativex();
  relativex_ = value;
}

// required float relativeY = 2 [default = -100000];
inline bool Ball::has_relativey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ball::set_has_relativey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ball::clear_has_relativey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ball::clear_relativey() {
  relativey_ = -100000;
  clear_has_relativey();
}
inline float Ball::relativey() const {
  return relativey_;
}
inline void Ball::set_relativey(float value) {
  set_has_relativey();
  relativey_ = value;
}

// required float relativeXspeed = 3 [default = 0];
inline bool Ball::has_relativexspeed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ball::set_has_relativexspeed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ball::clear_has_relativexspeed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ball::clear_relativexspeed() {
  relativexspeed_ = 0;
  clear_has_relativexspeed();
}
inline float Ball::relativexspeed() const {
  return relativexspeed_;
}
inline void Ball::set_relativexspeed(float value) {
  set_has_relativexspeed();
  relativexspeed_ = value;
}

// required float relativeYspeed = 4 [default = 0];
inline bool Ball::has_relativeyspeed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Ball::set_has_relativeyspeed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Ball::clear_has_relativeyspeed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Ball::clear_relativeyspeed() {
  relativeyspeed_ = 0;
  clear_has_relativeyspeed();
}
inline float Ball::relativeyspeed() const {
  return relativeyspeed_;
}
inline void Ball::set_relativeyspeed(float value) {
  set_has_relativeyspeed();
  relativeyspeed_ = value;
}

// required float absoluteX = 5 [default = -100000];
inline bool Ball::has_absolutex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Ball::set_has_absolutex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Ball::clear_has_absolutex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Ball::clear_absolutex() {
  absolutex_ = -100000;
  clear_has_absolutex();
}
inline float Ball::absolutex() const {
  return absolutex_;
}
inline void Ball::set_absolutex(float value) {
  set_has_absolutex();
  absolutex_ = value;
}

// required float absoluteY = 6 [default = -100000];
inline bool Ball::has_absolutey() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Ball::set_has_absolutey() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Ball::clear_has_absolutey() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Ball::clear_absolutey() {
  absolutey_ = -100000;
  clear_has_absolutey();
}
inline float Ball::absolutey() const {
  return absolutey_;
}
inline void Ball::set_absolutey(float value) {
  set_has_absolutey();
  absolutey_ = value;
}

// required float absoluteXspeed = 7 [default = 0];
inline bool Ball::has_absolutexspeed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Ball::set_has_absolutexspeed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Ball::clear_has_absolutexspeed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Ball::clear_absolutexspeed() {
  absolutexspeed_ = 0;
  clear_has_absolutexspeed();
}
inline float Ball::absolutexspeed() const {
  return absolutexspeed_;
}
inline void Ball::set_absolutexspeed(float value) {
  set_has_absolutexspeed();
  absolutexspeed_ = value;
}

// required float absoluteYspeed = 8 [default = 0];
inline bool Ball::has_absoluteyspeed() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Ball::set_has_absoluteyspeed() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Ball::clear_has_absoluteyspeed() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Ball::clear_absoluteyspeed() {
  absoluteyspeed_ = 0;
  clear_has_absoluteyspeed();
}
inline float Ball::absoluteyspeed() const {
  return absoluteyspeed_;
}
inline void Ball::set_absoluteyspeed(float value) {
  set_has_absoluteyspeed();
  absoluteyspeed_ = value;
}

// -------------------------------------------------------------------

// GlobalBall

// required float x = 1 [default = -100000];
inline bool GlobalBall::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GlobalBall::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GlobalBall::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GlobalBall::clear_x() {
  x_ = -100000;
  clear_has_x();
}
inline float GlobalBall::x() const {
  return x_;
}
inline void GlobalBall::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2 [default = -100000];
inline bool GlobalBall::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GlobalBall::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GlobalBall::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GlobalBall::clear_y() {
  y_ = -100000;
  clear_has_y();
}
inline float GlobalBall::y() const {
  return y_;
}
inline void GlobalBall::set_y(float value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// LocalizationResetMessage

// required int32 type = 1;
inline bool LocalizationResetMessage::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalizationResetMessage::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalizationResetMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalizationResetMessage::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 LocalizationResetMessage::type() const {
  return type_;
}
inline void LocalizationResetMessage::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required bool kickOff = 2;
inline bool LocalizationResetMessage::has_kickoff() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocalizationResetMessage::set_has_kickoff() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocalizationResetMessage::clear_has_kickoff() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocalizationResetMessage::clear_kickoff() {
  kickoff_ = false;
  clear_has_kickoff();
}
inline bool LocalizationResetMessage::kickoff() const {
  return kickoff_;
}
inline void LocalizationResetMessage::set_kickoff(bool value) {
  set_has_kickoff();
  kickoff_ = value;
}

// required float xPos = 3 [default = 0];
inline bool LocalizationResetMessage::has_xpos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocalizationResetMessage::set_has_xpos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocalizationResetMessage::clear_has_xpos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocalizationResetMessage::clear_xpos() {
  xpos_ = 0;
  clear_has_xpos();
}
inline float LocalizationResetMessage::xpos() const {
  return xpos_;
}
inline void LocalizationResetMessage::set_xpos(float value) {
  set_has_xpos();
  xpos_ = value;
}

// required float yPos = 4 [default = 0];
inline bool LocalizationResetMessage::has_ypos() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LocalizationResetMessage::set_has_ypos() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LocalizationResetMessage::clear_has_ypos() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LocalizationResetMessage::clear_ypos() {
  ypos_ = 0;
  clear_has_ypos();
}
inline float LocalizationResetMessage::ypos() const {
  return ypos_;
}
inline void LocalizationResetMessage::set_ypos(float value) {
  set_has_ypos();
  ypos_ = value;
}

// required float phiPos = 5 [default = 0];
inline bool LocalizationResetMessage::has_phipos() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LocalizationResetMessage::set_has_phipos() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LocalizationResetMessage::clear_has_phipos() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LocalizationResetMessage::clear_phipos() {
  phipos_ = 0;
  clear_has_phipos();
}
inline float LocalizationResetMessage::phipos() const {
  return phipos_;
}
inline void LocalizationResetMessage::set_phipos(float value) {
  set_has_phipos();
  phipos_ = value;
}

// -------------------------------------------------------------------

// LocalizationData

// required .WorldInfo World = 1;
inline bool LocalizationData::has_world() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalizationData::set_has_world() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalizationData::clear_has_world() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalizationData::clear_world() {
  if (world_ != NULL) world_->::WorldInfo::Clear();
  clear_has_world();
}
inline const ::WorldInfo& LocalizationData::world() const {
  return world_ != NULL ? *world_ : *default_instance_->world_;
}
inline ::WorldInfo* LocalizationData::mutable_world() {
  set_has_world();
  if (world_ == NULL) world_ = new ::WorldInfo;
  return world_;
}
inline ::WorldInfo* LocalizationData::release_world() {
  clear_has_world();
  ::WorldInfo* temp = world_;
  world_ = NULL;
  return temp;
}

// repeated .RobotPose Particles = 2;
inline int LocalizationData::particles_size() const {
  return particles_.size();
}
inline void LocalizationData::clear_particles() {
  particles_.Clear();
}
inline const ::RobotPose& LocalizationData::particles(int index) const {
  return particles_.Get(index);
}
inline ::RobotPose* LocalizationData::mutable_particles(int index) {
  return particles_.Mutable(index);
}
inline ::RobotPose* LocalizationData::add_particles() {
  return particles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RobotPose >&
LocalizationData::particles() const {
  return particles_;
}
inline ::google::protobuf::RepeatedPtrField< ::RobotPose >*
LocalizationData::mutable_particles() {
  return &particles_;
}

// required .RobotPose RobotPosition = 3;
inline bool LocalizationData::has_robotposition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocalizationData::set_has_robotposition() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocalizationData::clear_has_robotposition() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocalizationData::clear_robotposition() {
  if (robotposition_ != NULL) robotposition_->::RobotPose::Clear();
  clear_has_robotposition();
}
inline const ::RobotPose& LocalizationData::robotposition() const {
  return robotposition_ != NULL ? *robotposition_ : *default_instance_->robotposition_;
}
inline ::RobotPose* LocalizationData::mutable_robotposition() {
  set_has_robotposition();
  if (robotposition_ == NULL) robotposition_ = new ::RobotPose;
  return robotposition_;
}
inline ::RobotPose* LocalizationData::release_robotposition() {
  clear_has_robotposition();
  ::RobotPose* temp = robotposition_;
  robotposition_ = NULL;
  return temp;
}

// required .ObservationMessage Observations = 4;
inline bool LocalizationData::has_observations() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LocalizationData::set_has_observations() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LocalizationData::clear_has_observations() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LocalizationData::clear_observations() {
  if (observations_ != NULL) observations_->::ObservationMessage::Clear();
  clear_has_observations();
}
inline const ::ObservationMessage& LocalizationData::observations() const {
  return observations_ != NULL ? *observations_ : *default_instance_->observations_;
}
inline ::ObservationMessage* LocalizationData::mutable_observations() {
  set_has_observations();
  if (observations_ == NULL) observations_ = new ::ObservationMessage;
  return observations_;
}
inline ::ObservationMessage* LocalizationData::release_observations() {
  clear_has_observations();
  ::ObservationMessage* temp = observations_;
  observations_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// header

// required sint32 NextMsgByteSize = 1 [default = -1];
inline bool header::has_nextmsgbytesize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void header::set_has_nextmsgbytesize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void header::clear_has_nextmsgbytesize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void header::clear_nextmsgbytesize() {
  nextmsgbytesize_ = -1;
  clear_has_nextmsgbytesize();
}
inline ::google::protobuf::int32 header::nextmsgbytesize() const {
  return nextmsgbytesize_;
}
inline void header::set_nextmsgbytesize(::google::protobuf::int32 value) {
  set_has_nextmsgbytesize();
  nextmsgbytesize_ = value;
}

// required bytes NextMsgName = 3 [default = "Undef"];
inline bool header::has_nextmsgname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void header::set_has_nextmsgname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void header::clear_has_nextmsgname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void header::clear_nextmsgname() {
  if (nextmsgname_ != &_default_nextmsgname_) {
    nextmsgname_->assign(_default_nextmsgname_);
  }
  clear_has_nextmsgname();
}
inline const ::std::string& header::nextmsgname() const {
  return *nextmsgname_;
}
inline void header::set_nextmsgname(const ::std::string& value) {
  set_has_nextmsgname();
  if (nextmsgname_ == &_default_nextmsgname_) {
    nextmsgname_ = new ::std::string;
  }
  nextmsgname_->assign(value);
}
inline void header::set_nextmsgname(const char* value) {
  set_has_nextmsgname();
  if (nextmsgname_ == &_default_nextmsgname_) {
    nextmsgname_ = new ::std::string;
  }
  nextmsgname_->assign(value);
}
inline void header::set_nextmsgname(const void* value, size_t size) {
  set_has_nextmsgname();
  if (nextmsgname_ == &_default_nextmsgname_) {
    nextmsgname_ = new ::std::string;
  }
  nextmsgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* header::mutable_nextmsgname() {
  set_has_nextmsgname();
  if (nextmsgname_ == &_default_nextmsgname_) {
    nextmsgname_ = new ::std::string(_default_nextmsgname_);
  }
  return nextmsgname_;
}
inline ::std::string* header::release_nextmsgname() {
  clear_has_nextmsgname();
  if (nextmsgname_ == &_default_nextmsgname_) {
    return NULL;
  } else {
    ::std::string* temp = nextmsgname_;
    nextmsgname_ = const_cast< ::std::string*>(&_default_nextmsgname_);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LocalizationResetMessage_RESET>() {
  return ::LocalizationResetMessage_RESET_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_WorldInfo_2eproto__INCLUDED
