// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Kimage.proto

#ifndef PROTOBUF_Kimage_2eproto__INCLUDED
#define PROTOBUF_Kimage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Kimage_2eproto();
void protobuf_AssignDesc_Kimage_2eproto();
void protobuf_ShutdownFile_Kimage_2eproto();

class KRawImage;
class CalibrateCamMessage;

enum KRawImage_Colorspaces {
  KRawImage_Colorspaces_YUYV = 1,
  KRawImage_Colorspaces_OTHER = 2
};
bool KRawImage_Colorspaces_IsValid(int value);
const KRawImage_Colorspaces KRawImage_Colorspaces_Colorspaces_MIN = KRawImage_Colorspaces_YUYV;
const KRawImage_Colorspaces KRawImage_Colorspaces_Colorspaces_MAX = KRawImage_Colorspaces_OTHER;
const int KRawImage_Colorspaces_Colorspaces_ARRAYSIZE = KRawImage_Colorspaces_Colorspaces_MAX + 1;

const ::google::protobuf::EnumDescriptor* KRawImage_Colorspaces_descriptor();
inline const ::std::string& KRawImage_Colorspaces_Name(KRawImage_Colorspaces value) {
  return ::google::protobuf::internal::NameOfEnum(
    KRawImage_Colorspaces_descriptor(), value);
}
inline bool KRawImage_Colorspaces_Parse(
    const ::std::string& name, KRawImage_Colorspaces* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KRawImage_Colorspaces>(
    KRawImage_Colorspaces_descriptor(), name, value);
}
enum KRawImage_Camera {
  KRawImage_Camera_TOP = 0,
  KRawImage_Camera_BOTTOM = 1
};
bool KRawImage_Camera_IsValid(int value);
const KRawImage_Camera KRawImage_Camera_Camera_MIN = KRawImage_Camera_TOP;
const KRawImage_Camera KRawImage_Camera_Camera_MAX = KRawImage_Camera_BOTTOM;
const int KRawImage_Camera_Camera_ARRAYSIZE = KRawImage_Camera_Camera_MAX + 1;

const ::google::protobuf::EnumDescriptor* KRawImage_Camera_descriptor();
inline const ::std::string& KRawImage_Camera_Name(KRawImage_Camera value) {
  return ::google::protobuf::internal::NameOfEnum(
    KRawImage_Camera_descriptor(), value);
}
inline bool KRawImage_Camera_Parse(
    const ::std::string& name, KRawImage_Camera* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KRawImage_Camera>(
    KRawImage_Camera_descriptor(), name, value);
}
// ===================================================================

class KRawImage : public ::google::protobuf::Message {
 public:
  KRawImage();
  virtual ~KRawImage();
  
  KRawImage(const KRawImage& from);
  
  inline KRawImage& operator=(const KRawImage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const KRawImage& default_instance();
  
  void Swap(KRawImage* other);
  
  // implements Message ----------------------------------------------
  
  KRawImage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KRawImage& from);
  void MergeFrom(const KRawImage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef KRawImage_Colorspaces Colorspaces;
  static const Colorspaces YUYV = KRawImage_Colorspaces_YUYV;
  static const Colorspaces OTHER = KRawImage_Colorspaces_OTHER;
  static inline bool Colorspaces_IsValid(int value) {
    return KRawImage_Colorspaces_IsValid(value);
  }
  static const Colorspaces Colorspaces_MIN =
    KRawImage_Colorspaces_Colorspaces_MIN;
  static const Colorspaces Colorspaces_MAX =
    KRawImage_Colorspaces_Colorspaces_MAX;
  static const int Colorspaces_ARRAYSIZE =
    KRawImage_Colorspaces_Colorspaces_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Colorspaces_descriptor() {
    return KRawImage_Colorspaces_descriptor();
  }
  static inline const ::std::string& Colorspaces_Name(Colorspaces value) {
    return KRawImage_Colorspaces_Name(value);
  }
  static inline bool Colorspaces_Parse(const ::std::string& name,
      Colorspaces* value) {
    return KRawImage_Colorspaces_Parse(name, value);
  }
  
  typedef KRawImage_Camera Camera;
  static const Camera TOP = KRawImage_Camera_TOP;
  static const Camera BOTTOM = KRawImage_Camera_BOTTOM;
  static inline bool Camera_IsValid(int value) {
    return KRawImage_Camera_IsValid(value);
  }
  static const Camera Camera_MIN =
    KRawImage_Camera_Camera_MIN;
  static const Camera Camera_MAX =
    KRawImage_Camera_Camera_MAX;
  static const int Camera_ARRAYSIZE =
    KRawImage_Camera_Camera_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Camera_descriptor() {
    return KRawImage_Camera_descriptor();
  }
  static inline const ::std::string& Camera_Name(Camera value) {
    return KRawImage_Camera_Name(value);
  }
  static inline bool Camera_Parse(const ::std::string& name,
      Camera* value) {
    return KRawImage_Camera_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required uint32 bytes_per_pix = 1;
  inline bool has_bytes_per_pix() const;
  inline void clear_bytes_per_pix();
  static const int kBytesPerPixFieldNumber = 1;
  inline ::google::protobuf::uint32 bytes_per_pix() const;
  inline void set_bytes_per_pix(::google::protobuf::uint32 value);
  
  // required uint32 width = 2 [default = 0];
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 2;
  inline ::google::protobuf::uint32 width() const;
  inline void set_width(::google::protobuf::uint32 value);
  
  // required uint32 height = 3 [default = 0];
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 3;
  inline ::google::protobuf::uint32 height() const;
  inline void set_height(::google::protobuf::uint32 value);
  
  // required .KRawImage.Colorspaces colorspace = 4;
  inline bool has_colorspace() const;
  inline void clear_colorspace();
  static const int kColorspaceFieldNumber = 4;
  inline ::KRawImage_Colorspaces colorspace() const;
  inline void set_colorspace(::KRawImage_Colorspaces value);
  
  // required bytes image_rawdata = 5;
  inline bool has_image_rawdata() const;
  inline void clear_image_rawdata();
  static const int kImageRawdataFieldNumber = 5;
  inline const ::std::string& image_rawdata() const;
  inline void set_image_rawdata(const ::std::string& value);
  inline void set_image_rawdata(const char* value);
  inline void set_image_rawdata(const void* value, size_t size);
  inline ::std::string* mutable_image_rawdata();
  inline ::std::string* release_image_rawdata();
  
  // required int32 exposure_us = 6;
  inline bool has_exposure_us() const;
  inline void clear_exposure_us();
  static const int kExposureUsFieldNumber = 6;
  inline ::google::protobuf::int32 exposure_us() const;
  inline void set_exposure_us(::google::protobuf::int32 value);
  
  // required float luminance_scale = 7;
  inline bool has_luminance_scale() const;
  inline void clear_luminance_scale();
  static const int kLuminanceScaleFieldNumber = 7;
  inline float luminance_scale() const;
  inline void set_luminance_scale(float value);
  
  // required .KRawImage.Camera active_camera = 8;
  inline bool has_active_camera() const;
  inline void clear_active_camera();
  static const int kActiveCameraFieldNumber = 8;
  inline ::KRawImage_Camera active_camera() const;
  inline void set_active_camera(::KRawImage_Camera value);
  
  // @@protoc_insertion_point(class_scope:KRawImage)
 private:
  inline void set_has_bytes_per_pix();
  inline void clear_has_bytes_per_pix();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_colorspace();
  inline void clear_has_colorspace();
  inline void set_has_image_rawdata();
  inline void clear_has_image_rawdata();
  inline void set_has_exposure_us();
  inline void clear_has_exposure_us();
  inline void set_has_luminance_scale();
  inline void clear_has_luminance_scale();
  inline void set_has_active_camera();
  inline void clear_has_active_camera();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 bytes_per_pix_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  int colorspace_;
  ::std::string* image_rawdata_;
  ::google::protobuf::int32 exposure_us_;
  float luminance_scale_;
  int active_camera_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_Kimage_2eproto();
  friend void protobuf_AssignDesc_Kimage_2eproto();
  friend void protobuf_ShutdownFile_Kimage_2eproto();
  
  void InitAsDefaultInstance();
  static KRawImage* default_instance_;
};
// -------------------------------------------------------------------

class CalibrateCamMessage : public ::google::protobuf::Message {
 public:
  CalibrateCamMessage();
  virtual ~CalibrateCamMessage();
  
  CalibrateCamMessage(const CalibrateCamMessage& from);
  
  inline CalibrateCamMessage& operator=(const CalibrateCamMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CalibrateCamMessage& default_instance();
  
  void Swap(CalibrateCamMessage* other);
  
  // implements Message ----------------------------------------------
  
  CalibrateCamMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CalibrateCamMessage& from);
  void MergeFrom(const CalibrateCamMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool readConfiguration = 1;
  inline bool has_readconfiguration() const;
  inline void clear_readconfiguration();
  static const int kReadConfigurationFieldNumber = 1;
  inline bool readconfiguration() const;
  inline void set_readconfiguration(bool value);
  
  // @@protoc_insertion_point(class_scope:CalibrateCamMessage)
 private:
  inline void set_has_readconfiguration();
  inline void clear_has_readconfiguration();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool readconfiguration_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Kimage_2eproto();
  friend void protobuf_AssignDesc_Kimage_2eproto();
  friend void protobuf_ShutdownFile_Kimage_2eproto();
  
  void InitAsDefaultInstance();
  static CalibrateCamMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// KRawImage

// required uint32 bytes_per_pix = 1;
inline bool KRawImage::has_bytes_per_pix() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KRawImage::set_has_bytes_per_pix() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KRawImage::clear_has_bytes_per_pix() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KRawImage::clear_bytes_per_pix() {
  bytes_per_pix_ = 0u;
  clear_has_bytes_per_pix();
}
inline ::google::protobuf::uint32 KRawImage::bytes_per_pix() const {
  return bytes_per_pix_;
}
inline void KRawImage::set_bytes_per_pix(::google::protobuf::uint32 value) {
  set_has_bytes_per_pix();
  bytes_per_pix_ = value;
}

// required uint32 width = 2 [default = 0];
inline bool KRawImage::has_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KRawImage::set_has_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KRawImage::clear_has_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KRawImage::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 KRawImage::width() const {
  return width_;
}
inline void KRawImage::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
}

// required uint32 height = 3 [default = 0];
inline bool KRawImage::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KRawImage::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KRawImage::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KRawImage::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 KRawImage::height() const {
  return height_;
}
inline void KRawImage::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
}

// required .KRawImage.Colorspaces colorspace = 4;
inline bool KRawImage::has_colorspace() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KRawImage::set_has_colorspace() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KRawImage::clear_has_colorspace() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KRawImage::clear_colorspace() {
  colorspace_ = 1;
  clear_has_colorspace();
}
inline ::KRawImage_Colorspaces KRawImage::colorspace() const {
  return static_cast< ::KRawImage_Colorspaces >(colorspace_);
}
inline void KRawImage::set_colorspace(::KRawImage_Colorspaces value) {
  GOOGLE_DCHECK(::KRawImage_Colorspaces_IsValid(value));
  set_has_colorspace();
  colorspace_ = value;
}

// required bytes image_rawdata = 5;
inline bool KRawImage::has_image_rawdata() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void KRawImage::set_has_image_rawdata() {
  _has_bits_[0] |= 0x00000010u;
}
inline void KRawImage::clear_has_image_rawdata() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void KRawImage::clear_image_rawdata() {
  if (image_rawdata_ != &::google::protobuf::internal::kEmptyString) {
    image_rawdata_->clear();
  }
  clear_has_image_rawdata();
}
inline const ::std::string& KRawImage::image_rawdata() const {
  return *image_rawdata_;
}
inline void KRawImage::set_image_rawdata(const ::std::string& value) {
  set_has_image_rawdata();
  if (image_rawdata_ == &::google::protobuf::internal::kEmptyString) {
    image_rawdata_ = new ::std::string;
  }
  image_rawdata_->assign(value);
}
inline void KRawImage::set_image_rawdata(const char* value) {
  set_has_image_rawdata();
  if (image_rawdata_ == &::google::protobuf::internal::kEmptyString) {
    image_rawdata_ = new ::std::string;
  }
  image_rawdata_->assign(value);
}
inline void KRawImage::set_image_rawdata(const void* value, size_t size) {
  set_has_image_rawdata();
  if (image_rawdata_ == &::google::protobuf::internal::kEmptyString) {
    image_rawdata_ = new ::std::string;
  }
  image_rawdata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KRawImage::mutable_image_rawdata() {
  set_has_image_rawdata();
  if (image_rawdata_ == &::google::protobuf::internal::kEmptyString) {
    image_rawdata_ = new ::std::string;
  }
  return image_rawdata_;
}
inline ::std::string* KRawImage::release_image_rawdata() {
  clear_has_image_rawdata();
  if (image_rawdata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_rawdata_;
    image_rawdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 exposure_us = 6;
inline bool KRawImage::has_exposure_us() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void KRawImage::set_has_exposure_us() {
  _has_bits_[0] |= 0x00000020u;
}
inline void KRawImage::clear_has_exposure_us() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void KRawImage::clear_exposure_us() {
  exposure_us_ = 0;
  clear_has_exposure_us();
}
inline ::google::protobuf::int32 KRawImage::exposure_us() const {
  return exposure_us_;
}
inline void KRawImage::set_exposure_us(::google::protobuf::int32 value) {
  set_has_exposure_us();
  exposure_us_ = value;
}

// required float luminance_scale = 7;
inline bool KRawImage::has_luminance_scale() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void KRawImage::set_has_luminance_scale() {
  _has_bits_[0] |= 0x00000040u;
}
inline void KRawImage::clear_has_luminance_scale() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void KRawImage::clear_luminance_scale() {
  luminance_scale_ = 0;
  clear_has_luminance_scale();
}
inline float KRawImage::luminance_scale() const {
  return luminance_scale_;
}
inline void KRawImage::set_luminance_scale(float value) {
  set_has_luminance_scale();
  luminance_scale_ = value;
}

// required .KRawImage.Camera active_camera = 8;
inline bool KRawImage::has_active_camera() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void KRawImage::set_has_active_camera() {
  _has_bits_[0] |= 0x00000080u;
}
inline void KRawImage::clear_has_active_camera() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void KRawImage::clear_active_camera() {
  active_camera_ = 0;
  clear_has_active_camera();
}
inline ::KRawImage_Camera KRawImage::active_camera() const {
  return static_cast< ::KRawImage_Camera >(active_camera_);
}
inline void KRawImage::set_active_camera(::KRawImage_Camera value) {
  GOOGLE_DCHECK(::KRawImage_Camera_IsValid(value));
  set_has_active_camera();
  active_camera_ = value;
}

// -------------------------------------------------------------------

// CalibrateCamMessage

// required bool readConfiguration = 1;
inline bool CalibrateCamMessage::has_readconfiguration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CalibrateCamMessage::set_has_readconfiguration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CalibrateCamMessage::clear_has_readconfiguration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CalibrateCamMessage::clear_readconfiguration() {
  readconfiguration_ = false;
  clear_has_readconfiguration();
}
inline bool CalibrateCamMessage::readconfiguration() const {
  return readconfiguration_;
}
inline void CalibrateCamMessage::set_readconfiguration(bool value) {
  set_has_readconfiguration();
  readconfiguration_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KRawImage_Colorspaces>() {
  return ::KRawImage_Colorspaces_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KRawImage_Camera>() {
  return ::KRawImage_Camera_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Kimage_2eproto__INCLUDED
